emainder"){for(;ee<c.length;){const[oe,ie]=n.deserialize(c,ee);te.push(oe),ee=ie}return[te,ee]}const[ae,ne]=getResolvedSize(u,c,ee);ee=ne;for(let oe=0;oe<ae;oe+=1){const[ie,se]=n.deserialize(c,ee);te.push(ie),ee=se}return[te,ee]}}}function bool$1(n={}){const t=n.size??u8$1();if(t.fixedSize===null)throw new ExpectedFixedSizeSerializerError("Serializer [bool] requires a fixed size.");return{description:n.description??`bool(${t.description})`,fixedSize:t.fixedSize,maxSize:t.fixedSize,serialize:u=>t.serialize(u?1:0),deserialize:(u,c=0)=>{if(u.slice(c).length===0)throw new DeserializingEmptyBufferError("bool");const[ee,te]=t.deserialize(u,c);return[ee===1,te]}}}function bytes$2(n={}){const t=n.size??"variable",u=n.description??`bytes(${getSizeDescription(t)})`,c={description:u,fixedSize:null,maxSize:null,serialize:ee=>new Uint8Array(ee),deserialize:(ee,te=0)=>{const ae=ee.slice(te);return[ae,te+ae.length]}};return t==="variable"?c:typeof t=="number"?fixSerializer$1(c,t,u):{description:u,fixedSize:null,maxSize:null,serialize:ee=>{const te=c.serialize(ee),ae=t.serialize(te.length);return mergeBytes([ae,te])},deserialize:(ee,te=0)=>{if(ee.slice(te).length===0)throw new DeserializingEmptyBufferError("bytes");const[ae,ne]=t.deserialize(ee,te),oe=Number(ae);te=ne;const ie=ee.slice(te,te+oe);if(ie.length<oe)throw new NotEnoughBytesError("bytes",oe,ie.length);const[se,ue]=c.deserialize(ie);return te+=ue,[se,te]}}}function maxSerializerSizes$1(n){return n.reduce((t,u)=>t===null||u===null?null:Math.max(t,u),0)}function dataEnum$1(n,t={}){const u=t.size??u8$1(),c=n.map(([ne,oe])=>`${String(ne)}${oe?`: ${oe.description}`:""}`).join(", "),te=n.every((ne,oe,ie)=>ne[1].fixedSize===ie[0][1].fixedSize)?n[0][1].fixedSize:null,ae=maxSerializerSizes$1(n.map(([,ne])=>ne.maxSize));return{description:t.description??`dataEnum(${c}; ${u.description})`,fixedSize:n.length===0?u.fixedSize:sumSerializerSizes$1([u.fixedSize,te]),maxSize:n.length===0?u.maxSize:sumSerializerSizes$1([u.maxSize,ae]),serialize:ne=>{const oe=n.findIndex(([le])=>ne.__kind===le);if(oe<0)throw new InvalidDataEnumVariantError(ne.__kind,n.map(([le])=>le));const ie=u.serialize(oe),ue=n[oe][1].serialize(ne);return mergeBytes([ie,ue])},deserialize:(ne,oe=0)=>{if(ne.slice(oe).length===0)throw new DeserializingEmptyBufferError("dataEnum");const[ie,se]=u.deserialize(ne,oe);oe=se;const ue=n[Number(ie)]??null;if(!ue)throw new EnumDiscriminatorOutOfRangeError(ie,0,n.length-1);const[le,ce]=ue[1].deserialize(ne,oe);return oe=ce,[{__kind:ue[0],...le??{}},oe]}}}function map$2(n,t,u={}){const c=u.size??u32$1();return{description:u.description??`map(${n.description}, ${t.description}; ${getSizeDescription(c)})`,fixedSize:getSizeFromChildren(c,[n.fixedSize,t.fixedSize]),maxSize:getSizeFromChildren(c,[n.maxSize,t.maxSize]),serialize:ee=>{if(typeof c=="number"&&ee.size!==c)throw new InvalidNumberOfItemsError("map",c,ee.size);const te=Array.from(ee,([ae,ne])=>mergeBytes([n.serialize(ae),t.serialize(ne)]));return mergeBytes([getSizePrefix(c,ee.size),...te])},deserialize:(ee,te=0)=>{const ae=new Map;if(typeof c=="object"&&ee.slice(te).length===0)return[ae,te];if(c==="remainder"){for(;te<ee.length;){const[ie,se]=n.deserialize(ee,te);te=se;const[ue,le]=t.deserialize(ee,te);te=le,ae.set(ie,ue)}return[ae,te]}const[ne,oe]=getResolvedSize(c,ee,te);te=oe;for(let ie=0;ie<ne;ie+=1){const[se,ue]=n.deserialize(ee,te);te=ue;const[le,ce]=t.deserialize(ee,te);te=ce,ae.set(se,le)}return[ae,te]}}}function nullable$1(n,t={}){const u=t.prefix??u8$1(),c=t.fixed??!1;let ee=`; ${getSizeDescription(u)}`,te=n.fixedSize===0?u.fixedSize:null;if(c){if(n.fixedSize===null||u.fixedSize===null)throw new ExpectedFixedSizeSerializerError("Fixed nullables can only be used with fixed-size serializers");ee+="; fixed",te=u.fixedSize+n.fixedSize}return{description:t.description??`nullable(${n.description+ee})`,fixedSize:te,maxSize:sumSerializerSizes$1([u.maxSize,n.maxSize]),serialize:ae=>{const ne=u.serialize(+(ae!==null));if(c){const ie=n.fixedSize,se=ae!==null?n.serialize(ae).slice(0,ie):new Uint8Array(ie).fill(0);return mergeBytes([ne,se])}const oe=ae!==null?n.serialize(ae):new Uint8Array;return mergeBytes([ne,oe])},deserialize:(ae,ne=0)=>{if(ae.slice(ne).length===0)return[null,ne];const oe=ne+(u.fixedSize??0)+(n.fixedSize??0),[ie,se]=u.deserialize(ae,ne);if(ne=se,ie===0)return[null,c?oe:ne];const[ue,le]=n.deserialize(ae,ne);return ne=le,[ue,c?oe:ne]}}}function option$1(n,t={}){const u=t.prefix??u8$1(),c=t.fixed??!1;let ee=`; ${getSizeDescription(u)}`,te=n.fixedSize===0?u.fixedSize:null;if(c){if(n.fixedSize===null||u.fixedSize===null)throw new ExpectedFixedSizeSerializerError("Fixed options can only be used with fixed-size serializers");ee+="; fixed",te=u.fixedSize+n.fixedSize}return{description:t.description??`option(${n.description+ee})`,fixedSize:te,maxSize:sumSerializerSizes$1([u.maxSize,n.maxSize]),serialize:ae=>{const ne=isOption(ae)?ae:wrapNullable(ae),oe=u.serialize(Number(isSome(ne)));if(c){const se=n.fixedSize,ue=isSome(ne)?n.serialize(ne.value).slice(0,se):new Uint8Array(se).fill(0);return mergeBytes([oe,ue])}const ie=isSome(ne)?n.serialize(ne.value):new Uint8Array;return mergeBytes([oe,ie])},deserialize:(ae,ne=0)=>{if(ae.slice(ne).length===0)return[none(),ne];const oe=ne+(u.fixedSize??0)+(n.fixedSize??0),[ie,se]=u.deserialize(ae,ne);if(ne=se,ie===0)return[none(),c?oe:ne];const[ue,le]=n.deserialize(ae,ne);return ne=le,[some(ue),c?oe:ne]}}}function publicKey$1(n={}){return{description:n.description??"publicKey",fixedSize:32,maxSize:32,serialize:t=>publicKeyBytes(publicKey$2(t)),deserialize:(t,u=0)=>{const c=t.slice(u,u+32);if(c.length===0)throw new DeserializingEmptyBufferError("publicKey");if(c.length<PUBLIC_KEY_LENGTH)throw new NotEnoughBytesError("publicKey",PUBLIC_KEY_LENGTH,c.length);return[publicKey$2(c),u+32]}}}function scalarEnum$1(n,t={}){const u=t.size??u8$1(),c=Object.keys(n),ee=Object.values(n),te=ee.some(ue=>typeof ue=="number"),ae=ee.filter(ue=>typeof ue=="string").join(", "),ne=0,oe=te?ee.length/2-1:ee.length-1,ie=te?[...c]:[...new Set([...c,...ee])];function se(ue){const le=typeof ue=="number"&&(ue<ne||ue>oe),ce=typeof ue=="string"&&!ie.includes(ue);if(le||ce)throw new InvalidScalarEnumVariantError(ue,ie,ne,oe)}return{description:t.description??`enum(${ae}; ${u.description})`,fixedSize:u.fixedSize,maxSize:u.maxSize,serialize:ue=>{if(se(ue),typeof ue=="number")return u.serialize(ue);const le=ee.indexOf(ue);return le>=0?u.serialize(le):u.serialize(c.indexOf(ue))},deserialize:(ue,le=0)=>{if(ue.slice(le).length===0)throw new DeserializingEmptyBufferError("enum");const[ce,de]=u.deserialize(ue,le),fe=Number(ce);if(le=de,fe<ne||fe>oe)throw new EnumDiscriminatorOutOfRangeError(fe,ne,oe);return[te?fe:ee[fe],le]}}}function set$2(n,t={}){const u=t.size??u32$1();return{description:t.description??`set(${n.description}; ${getSizeDescription(u)})`,fixedSize:getSizeFromChildren(u,[n.fixedSize]),maxSize:getSizeFromChildren(u,[n.maxSize]),serialize:c=>{if(typeof u=="number"&&c.size!==u)throw new InvalidNumberOfItemsError("set",u,c.size);const ee=Array.from(c,te=>n.serialize(te));return mergeBytes([getSizePrefix(u,c.size),...ee])},deserialize:(c,ee=0)=>{const te=new Set;if(typeof u=="object"&&c.slice(ee).length===0)return[te,ee];if(u==="remainder"){for(;ee<c.length;){const[oe,ie]=n.deserialize(c,ee);te.add(oe),ee=ie}return[te,ee]}const[ae,ne]=getResolvedSize(u,c,ee);ee=ne;for(let oe=0;oe<ae;oe+=1){const[ie,se]=n.deserialize(c,ee);te.add(ie),ee=se}return[te,ee]}}}function string$2(n={}){const t=n.size??u32$1(),u=n.encoding??utf8$1,c=n.description??`string(${u.description}; ${getSizeDescription(t)})`;return t==="variable"?{...u,description:c}:typeof t=="number"?fixSerializer$1(u,t,c):{description:c,fixedSize:null,maxSize:null,serialize:ee=>{const te=u.serialize(ee),ae=t.serialize(te.length);return mergeBytes([ae,te])},deserialize:(ee,te=0)=>{if(ee.slice(te).length===0)throw new DeserializingEmptyBufferError("string");const[ae,ne]=t.deserialize(ee,te),oe=Number(ae);te=ne;const ie=ee.slice(te,te+oe);if(ie.length<oe)throw new NotEnoughBytesError("string",oe,ie.length);const[se,ue]=u.deserialize(ie);return te+=ue,[se,te]}}}function struct$1(n,t={}){const u=n.map(([c,ee])=>`${String(c)}: ${ee.description}`).join(", ");return{description:t.description??`struct(${u})`,fixedSize:sumSerializerSizes$1(n.map(([,c])=>c.fixedSize)),maxSize:sumSerializerSizes$1(n.map(([,c])=>c.maxSize)),serialize:c=>{const ee=n.map(([te,ae])=>ae.serialize(c[te]));return mergeBytes(ee)},deserialize:(c,ee=0)=>{const te={};return n.forEach(([ae,ne])=>{const[oe,ie]=ne.deserialize(c,ee);ee=ie,te[ae]=oe}),[te,ee]}}}function tuple$1(n,t={}){const u=n.map(c=>c.description).join(", ");return{description:t.description??`tuple(${u})`,fixedSize:sumSerializerSizes$1(n.map(c=>c.fixedSize)),maxSize:sumSerializerSizes$1(n.map(c=>c.maxSize)),serialize:c=>{if(c.length!==n.length)throw new InvalidNumberOfItemsError("tuple",n.length,c.length);return mergeBytes(n.map((ee,te)=>ee.serialize(c[te])))},deserialize:(c,ee=0)=>{const te=[];return n.forEach(ae=>{const[ne,oe]=ae.deserialize(c,ee);te.push(ne),ee=oe}),[te,ee]}}}function unit$1(n={}){return{description:n.description??"unit",fixedSize:0,maxSize:0,serialize:()=>new Uint8Array,deserialize:(t,u=0)=>[void 0,u]}}const base58$1=base58$2;let UmiError$1=class extends Error{constructor(u,c,ee,te){super(u);Ca(this,"name","UmiError");this.source=c,this.sourceDetails=ee,this.cause=te,this.message=`${this.message}

Source: ${this.getFullSource()}${this.cause?`

Caused By: ${this.cause}`:""}
`}getCapitalizedSource(){return this.source==="sdk"||this.source==="rpc"?this.source.toUpperCase():this.source[0].toUpperCase()+this.source.slice(1)}getFullSource(){const u=this.getCapitalizedSource(),c=this.sourceDetails?` > ${this.sourceDetails}`:"";return u+c}toString(){return`[${this.name}] ${this.message}`}},SdkError$1=class extends UmiError$1{constructor(u,c){super(u,"sdk",void 0,c);Ca(this,"name","SdkError")}};const ACCOUNT_HEADER_SIZE=128,createBigInt=n=>(n=typeof n=="object"?n.toString():n,BigInt(n)),createAmount=(n,t,u)=>({basisPoints:createBigInt(n),identifier:t,decimals:u}),lamports=n=>createAmount(n,"SOL",9),isZeroAmount=n=>n.basisPoints===BigInt(0),MAINNET_BETA_DOMAINS=["api.mainnet-beta.solana.com","ssc-dao.genesysgo.net"],DEVNET_DOMAINS=["api.devnet.solana.com","psytrbhymqlkfrhudd.dev.genesysgo.net"],TESTNET_DOMAINS=["api.testnet.solana.com"],LOCALNET_DOMAINS=["localhost","127.0.0.1"],resolveClusterFromEndpoint=n=>{const t=new URL(n).hostname;return MAINNET_BETA_DOMAINS.includes(t)?"mainnet-beta":DEVNET_DOMAINS.includes(t)?"devnet":TESTNET_DOMAINS.includes(t)?"testnet":LOCALNET_DOMAINS.includes(t)?"localnet":n.includes("mainnet")?"mainnet-beta":n.includes("devnet")?"devnet":n.includes("testnet")?"testnet":n.includes("local")?"localnet":"custom"};let InterfaceImplementationMissingError$1=class extends SdkError$1{constructor(u,c){const ee=u.replace(/Interface$/,""),te=`Tried using ${u} but no implementation of that interface was found. Make sure an implementation is registered, e.g. via "context.${c} = new My${ee}();".`;super(te);Ca(this,"name","InterfaceImplementationMissingError")}};function createNullDownloader(){const n=()=>{throw new InterfaceImplementationMissingError$1("DownloaderInterface","downloader")};return{download:n,downloadJson:n}}function createNullEddsa(){const n=()=>{throw new InterfaceImplementationMissingError$1("EddsaInterface","eddsa")};return{generateKeypair:n,createKeypairFromSecretKey:n,createKeypairFromSeed:n,createKeypairFromFile:n,createKeypairFromSolanaConfig:n,isOnCurve:n,findPda:n,sign:n,verify:n}}function createNullHttp(){return{send:()=>{throw new InterfaceImplementationMissingError$1("HttpInterface","http")}}}function createNullProgramRepository(){const n=()=>{throw new InterfaceImplementationMissingError$1("ProgramRepositoryInterface","programs")};return{has:n,get:n,getPublicKey:n,all:n,add:n,bind:n,unbind:n,clone:n,resolveError:n}}function createNullRpc(){const n=()=>{throw new InterfaceImplementationMissingError$1("RpcInterface","rpc")};return{getEndpoint:n,getCluster:n,getAccount:n,getAccounts:n,getProgramAccounts:n,getBlockTime:n,getBalance:n,getRent:n,getSlot:n,getGenesisHash:n,getLatestBlockhash:n,getTransaction:n,getSignatureStatuses:n,accountExists:n,airdrop:n,call:n,sendTransaction:n,simulateTransaction:n,confirmTransaction:n}}function createNullSerializer(){const n=()=>{throw new InterfaceImplementationMissingError$1("SerializerInterface","serializer")};return{tuple:n,array:n,map:n,set:n,option:n,nullable:n,struct:n,enum:n,dataEnum:n,string:n,bool:n,unit:n,u8:n,u16:n,u32:n,u64:n,u128:n,i8:n,i16:n,i32:n,i64:n,i128:n,f32:n,f64:n,bytes:n,publicKey:n}}const chunk=(n,t)=>n.reduce((u,c,ee)=>{const te=Math.floor(ee/t);return u[te]||(u[te]=[]),u[te].push(c),u},[]);function createNullSigner(){const n=new Error("Trying to use a NullSigner. Did you forget to set a Signer on your Umi instance? See the `signerIdentity` method for more information."),t=()=>{throw n};return{get publicKey(){throw n},signMessage:t,signTransaction:t,signAllTransactions:t}}function createNullTransactionFactory(){const n=()=>{throw new InterfaceImplementationMissingError$1("TransactionFactoryInterface","transactions")};return{create:n,serialize:n,deserialize:n,serializeMessage:n,deserializeMessage:n}}function createNullUploader(){const n=()=>{throw new InterfaceImplementationMissingError$1("UploaderInterface","uploader")};return{upload:n,uploadJson:n,getUploadPrice:n}}const createNullContext=()=>({downloader:createNullDownloader(),eddsa:createNullEddsa(),http:createNullHttp(),identity:createNullSigner(),payer:createNullSigner(),programs:createNullProgramRepository(),rpc:createNullRpc(),serializer:createNullSerializer(),transactions:createNullTransactionFactory(),uploader:createNullUploader()}),dateTime=n=>{if(typeof n=="string"||isDateObject(n)){const t=new Date(n),u=Math.floor(t.getTime()/1e3);return createBigInt(u)}return createBigInt(n)},isDateObject=n=>Object.prototype.toString.call(n)==="[object Date]",generateRandomString=(n=20,t="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789")=>{let u="";const c=t.length;for(let ee=0;ee<n;ee+=1)u+=t.charAt(Math.floor(Math.random()*c));return u},createGenericFile=(n,t,u={})=>({buffer:typeof n=="string"?utf8$1.serialize(n):n,fileName:t,displayName:u.displayName??t,uniqueName:u.uniqueName??generateRandomString(),contentType:u.contentType??null,extension:u.extension??getExtension(t),tags:u.tags??[]}),getExtension=n=>{const t=n.lastIndexOf(".");return t<0?null:n.slice(t+1)},request=()=>new HttpRequestBuilder({method:"get",data:void 0,headers:{},url:""});class HttpRequestBuilder{constructor(t){this.request=t}asJson(){return this.contentType("application/json")}asMultipart(){return this.contentType("multipart/form-data")}asForm(){return this.contentType("application/x-www-form-urlencoded")}accept(t){return this.withHeader("accept",t)}contentType(t){return this.withHeader("content-type",t)}userAgent(t){return this.withHeader("user-agent",t)}withToken(t,u="Bearer"){return this.withHeader("authorization",`${u} ${t}`)}withHeader(t,u){return this.withHeaders({[t]:u})}withHeaders(t){return new HttpRequestBuilder({...this.request,headers:{...this.request.headers,...t}})}dontFollowRedirects(){return this.followRedirects(0)}followRedirects(t){return new HttpRequestBuilder({...this.request,maxRedirects:t})}withoutTimeout(){return this.withTimeout(0)}withTimeout(t){return new HttpRequestBuilder({...this.request,timeout:t})}withAbortSignal(t){return new HttpRequestBuilder({...this.request,signal:t})}withEndpoint(t,u){return new HttpRequestBuilder({...this.request,method:t,url:u})}withParams(t){const u=new URL(this.request.url),c=new URLSearchParams(t),ee=new URLSearchParams(u.searchParams);return[...c.entries()].forEach(([te,ae])=>{ee.append(te,ae)}),u.search=ee.toString(),new HttpRequestBuilder({...this.request,url:u.toString()})}withData(t){return new HttpRequestBuilder({...this.request,data:t})}get(t){return this.withEndpoint("get",t)}post(t){return this.withEndpoint("post",t)}put(t){return this.withEndpoint("put",t)}patch(t){return this.withEndpoint("patch",t)}delete(t){return this.withEndpoint("delete",t)}get method(){return this.request.method}get url(){return this.request.url}get data(){return this.request.data}get headers(){return this.request.headers}get maxRedirects(){return this.request.maxRedirects}get timeout(){return this.request.timeout}get signal(){return this.request.signal}}const createUmi$1=()=>({...createNullContext(),use(n){return n.install(this),this}});let ProgramError$1=class extends UmiError$1{constructor(u,c,ee){super(u,"program",`${c.name} [${c.publicKey}]`,ee);Ca(this,"name","ProgramError");this.program=c,this.logs=ee==null?void 0:ee.logs,this.logs&&(this.message+=`
Program Logs:
${this.logs.map(te=>`| ${te}`).join(`
`)}
`)}};function createHttpDownloader(n){const t=async(ee,te={})=>{const ae=await n.http.send(request().get(ee).withAbortSignal(te.signal));return createGenericFile(ae.body,ee)};return{download:async(ee,te={})=>Promise.all(ee.map(ae=>t(ae,te))),downloadJson:async(ee,te={})=>(await n.http.send(request().get(ee).withAbortSignal(te.signal))).data}}const httpDownloader=()=>({install(n){n.downloader=createHttpDownloader(n)}});function fromWeb3JsPublicKey(n){return n.toBase58()}function toWeb3JsPublicKey(n){return new PublicKey(n)}function toWeb3JsInstruction(n){return new TransactionInstruction({keys:n.keys.map(t=>({...t,pubkey:toWeb3JsPublicKey(t.pubkey)})),programId:toWeb3JsPublicKey(n.programId),data:Buffer$1.from(n.data)})}function fromWeb3JsKeypair(n){return{publicKey:fromWeb3JsPublicKey(n.publicKey),secretKey:n.secretKey}}function fromWeb3JsMessage(n){return{version:n.version,header:n.header,accounts:n.staticAccountKeys.map(fromWeb3JsPublicKey),blockhash:n.recentBlockhash,instructions:n.compiledInstructions.map(t=>({programIndex:t.programIdIndex,accountIndexes:t.accountKeyIndexes,data:new Uint8Array(t.data)})),addressLookupTables:n.addressTableLookups.map(t=>({publicKey:fromWeb3JsPublicKey(t.accountKey),writableIndexes:t.writableIndexes,readonlyIndexes:t.readonlyIndexes}))}}function toWeb3JsMessage(n){return n.version==="legacy"?new Message({header:n.header,accountKeys:n.accounts.map(toWeb3JsPublicKey),recentBlockhash:n.blockhash,instructions:n.instructions.map(t=>({programIdIndex:t.programIndex,accounts:t.accountIndexes,data:base58$1.deserialize(t.data)[0]}))}):new MessageV0({header:n.header,staticAccountKeys:n.accounts.map(toWeb3JsPublicKey),recentBlockhash:n.blockhash,compiledInstructions:n.instructions.map(t=>({programIdIndex:t.programIndex,accountKeyIndexes:t.accountIndexes,data:t.data})),addressTableLookups:n.addressLookupTables.map(t=>({accountKey:toWeb3JsPublicKey(t.publicKey),writableIndexes:t.writableIndexes,readonlyIndexes:t.readonlyIndexes}))})}function toWeb3JsMessageFromInput(n){var t;return n.version==="legacy"?Message.compile({payerKey:toWeb3JsPublicKey(n.payer),instructions:n.instructions.map(toWeb3JsInstruction),recentBlockhash:n.blockhash}):MessageV0.compile({payerKey:toWeb3JsPublicKey(n.payer),instructions:n.instructions.map(toWeb3JsInstruction),recentBlockhash:n.blockhash,addressLookupTableAccounts:(t=n.addressLookupTables)==null?void 0:t.map(u=>new AddressLookupTableAccount({key:toWeb3JsPublicKey(u.publicKey),state:{addresses:u.addresses.map(toWeb3JsPublicKey),authority:void 0,deactivationSlot:BigInt(`0x${"ff".repeat(8)}`),lastExtendedSlot:0,lastExtendedSlotStartIndex:0}}))})}function toWeb3JsTransaction(n){return new VersionedTransaction(toWeb3JsMessage(n.message),n.signatures)}const readFileSync=()=>{},writeFileSync=()=>{};var browser={},hasRequiredBrowser;function requireBrowser(){return hasRequiredBrowser||(hasRequiredBrowser=1,browser.endianness=function(){return"LE"},browser.hostname=function(){return typeof location<"u"?location.hostname:""},browser.loadavg=function(){return[]},browser.uptime=function(){return 0},browser.freemem=function(){return Number.MAX_VALUE},browser.totalmem=function(){return Number.MAX_VALUE},browser.cpus=function(){return[]},browser.type=function(){return"Browser"},browser.release=function(){return typeof navigator<"u"?navigator.appVersion:""},browser.networkInterfaces=browser.getNetworkInterfaces=function(){return{}},browser.arch=function(){return"javascript"},browser.platform=function(){return"browser"},browser.tmpdir=browser.tmpDir=function(){return"/tmp"},browser.EOL=`
`,browser.homedir=function(){return"/"}),browser}var browserExports=requireBrowser();const ALIAS=Symbol.for("yaml.alias"),DOC=Symbol.for("yaml.document"),MAP$1=Symbol.for("yaml.map"),PAIR=Symbol.for("yaml.pair"),SCALAR$1=Symbol.for("yaml.scalar"),SEQ=Symbol.for("yaml.seq"),NODE_TYPE=Symbol.for("yaml.node.type"),isAlias=n=>!!n&&typeof n=="object"&&n[NODE_TYPE]===ALIAS,isDocument=n=>!!n&&typeof n=="object"&&n[NODE_TYPE]===DOC,isMap=n=>!!n&&typeof n=="object"&&n[NODE_TYPE]===MAP$1,isPair=n=>!!n&&typeof n=="object"&&n[NODE_TYPE]===PAIR,isScalar=n=>!!n&&typeof n=="object"&&n[NODE_TYPE]===SCALAR$1,isSeq=n=>!!n&&typeof n=="object"&&n[NODE_TYPE]===SEQ;function isCollection(n){if(n&&typeof n=="object")switch(n[NODE_TYPE]){case MAP$1:case SEQ:return!0}return!1}function isNode(n){if(n&&typeof n=="object")switch(n[NODE_TYPE]){case ALIAS:case MAP$1:case SCALAR$1:case SEQ:return!0}return!1}const hasAnchor=n=>(isScalar(n)||isCollection(n))&&!!n.anchor,BREAK=Symbol("break visit"),SKIP=Symbol("skip children"),REMOVE=Symbol("remove node");function visit(n,t){const u=initVisitor(t);isDocument(n)?visit_(null,n.contents,u,Object.freeze([n]))===REMOVE&&(n.contents=null):visit_(null,n,u,Object.freeze([]))}visit.BREAK=BREAK;visit.SKIP=SKIP;visit.REMOVE=REMOVE;function visit_(n,t,u,c){const ee=callVisitor(n,t,u,c);if(isNode(ee)||isPair(ee))return replaceNode(n,c,ee),visit_(n,ee,u,c);if(typeof ee!="symbol"){if(isCollection(t)){c=Object.freeze(c.concat(t));for(let te=0;te<t.items.length;++te){const ae=visit_(te,t.items[te],u,c);if(typeof ae=="number")te=ae-1;else{if(ae===BREAK)return BREAK;ae===REMOVE&&(t.items.splice(te,1),te-=1)}}}else if(isPair(t)){c=Object.freeze(c.concat(t));const te=visit_("key",t.key,u,c);if(te===BREAK)return BREAK;te===REMOVE&&(t.key=null);const ae=visit_("value",t.value,u,c);if(ae===BREAK)return BREAK;ae===REMOVE&&(t.value=null)}}return ee}function initVisitor(n){return typeof n=="object"&&(n.Collection||n.Node||n.Value)?Object.assign({Alias:n.Node,Map:n.Node,Scalar:n.Node,Seq:n.Node},n.Value&&{Map:n.Value,Scalar:n.Value,Seq:n.Value},n.Collection&&{Map:n.Collection,Seq:n.Collection},n):n}function callVisitor(n,t,u,c){var ee,te,ae,ne,oe;if(typeof u=="function")return u(n,t,c);if(isMap(t))return(ee=u.Map)==null?void 0:ee.call(u,n,t,c);if(isSeq(t))return(te=u.Seq)==null?void 0:te.call(u,n,t,c);if(isPair(t))return(ae=u.Pair)==null?void 0:ae.call(u,n,t,c);if(isScalar(t))return(ne=u.Scalar)==null?void 0:ne.call(u,n,t,c);if(isAlias(t))return(oe=u.Alias)==null?void 0:oe.call(u,n,t,c)}function replaceNode(n,t,u){const c=t[t.length-1];if(isCollection(c))c.items[n]=u;else if(isPair(c))n==="key"?c.key=u:c.value=u;else if(isDocument(c))c.contents=u;else{const ee=isAlias(c)?"alias":"scalar";throw new Error(`Cannot replace node with ${ee} parent`)}}const escapeChars={"!":"%21",",":"%2C","[":"%5B","]":"%5D","{":"%7B","}":"%7D"},escapeTagName=n=>n.replace(/[!,[\]{}]/g,t=>escapeChars[t]);class Directives{constructor(t,u){this.docStart=null,this.docEnd=!1,this.yaml=Object.assign({},Directives.defaultYaml,t),this.tags=Object.assign({},Directives.defaultTags,u)}clone(){const t=new Directives(this.yaml,this.tags);return t.docStart=this.docStart,t}atDocument(){const t=new Directives(this.yaml,this.tags);switch(this.yaml.version){case"1.1":this.atNextDocument=!0;break;case"1.2":this.atNextDocument=!1,this.yaml={explicit:Directives.defaultYaml.explicit,version:"1.2"},this.tags=Object.assign({},Directives.defaultTags);break}return t}add(t,u){this.atNextDocument&&(this.yaml={explicit:Directives.defaultYaml.explicit,version:"1.1"},this.tags=Object.assign({},Directives.defaultTags),this.atNextDocument=!1);const c=t.trim().split(/[ \t]+/),ee=c.shift();switch(ee){case"%TAG":{if(c.length!==2&&(u(0,"%TAG directive should contain exactly two parts"),c.length<2))return!1;const[te,ae]=c;return this.tags[te]=ae,!0}case"%YAML":{if(this.yaml.explicit=!0,c.length!==1)return u(0,"%YAML directive should contain exactly one part"),!1;const[te]=c;if(te==="1.1"||te==="1.2")return this.yaml.version=te,!0;{const ae=/^\d+\.\d+$/.test(te);return u(6,`Unsupported YAML version ${te}`,ae),!1}}default:return u(0,`Unknown directive ${ee}`,!0),!1}}tagName(t,u){if(t==="!")return"!";if(t[0]!=="!")return u(`Not a valid tag: ${t}`),null;if(t[1]==="<"){const ae=t.slice(2,-1);return ae==="!"||ae==="!!"?(u(`Verbatim tags aren't resolved, so ${t} is invalid.`),null):(t[t.length-1]!==">"&&u("Verbatim tags must end with a >"),ae)}const[,c,ee]=t.match(/^(.*!)([^!]*)$/s);ee||u(`The ${t} tag has no suffix`);const te=this.tags[c];if(te)try{return te+decodeURIComponent(ee)}catch(ae){return u(String(ae)),null}return c==="!"?t:(u(`Could not resolve tag: ${t}`),null)}tagString(t){for(const[u,c]of Object.entries(this.tags))if(t.startsWith(c))return u+escapeTagName(t.substring(c.length));return t[0]==="!"?t:`!<${t}>`}toString(t){const u=this.yaml.explicit?[`%YAML ${this.yaml.version||"1.2"}`]:[],c=Object.entries(this.tags);let ee;if(t&&c.length>0&&isNode(t.contents)){const te={};visit(t.contents,(ae,ne)=>{isNode(ne)&&ne.tag&&(te[ne.tag]=!0)}),ee=Object.keys(te)}else ee=[];for(const[te,ae]of c)te==="!!"&&ae==="tag:yaml.org,2002:"||(!t||ee.some(ne=>ne.startsWith(ae)))&&u.push(`%TAG ${te} ${ae}`);return u.join(`
`)}}Directives.defaultYaml={explicit:!1,version:"1.2"};Directives.defaultTags={"!!":"tag:yaml.org,2002:"};function anchorIsValid(n){if(/[\x00-\x19\s,[\]{}]/.test(n)){const u=`Anchor must not contain whitespace or control characters: ${JSON.stringify(n)}`;throw new Error(u)}return!0}function anchorNames(n){const t=new Set;return visit(n,{Value(u,c){c.anchor&&t.add(c.anchor)}}),t}function findNewAnchor(n,t){for(let u=1;;++u){const c=`${n}${u}`;if(!t.has(c))return c}}function createNodeAnchors(n,t){const u=[],c=new Map;let ee=null;return{onAnchor:te=>{u.push(te),ee||(ee=anchorNames(n));const ae=findNewAnchor(t,ee);return ee.add(ae),ae},setAnchors:()=>{for(const te of u){const ae=c.get(te);if(typeof ae=="object"&&ae.anchor&&(isScalar(ae.node)||isCollection(ae.node)))ae.node.anchor=ae.anchor;else{const ne=new Error("Failed to resolve repeated object (this should not happen)");throw ne.source=te,ne}}},sourceObjects:c}}function applyReviver(n,t,u,c){if(c&&typeof c=="object")if(Array.isArray(c))for(let ee=0,te=c.length;ee<te;++ee){const ae=c[ee],ne=applyReviver(n,c,String(ee),ae);ne===void 0?delete c[ee]:ne!==ae&&(c[ee]=ne)}else if(c instanceof Map)for(const ee of Array.from(c.keys())){const te=c.get(ee),ae=applyReviver(n,c,ee,te);ae===void 0?c.delete(ee):ae!==te&&c.set(ee,ae)}else if(c instanceof Set)for(const ee of Array.from(c)){const te=applyReviver(n,c,ee,ee);te===void 0?c.delete(ee):te!==ee&&(c.delete(ee),c.add(te))}else for(const[ee,te]of Object.entries(c)){const ae=applyReviver(n,c,ee,te);ae===void 0?delete c[ee]:ae!==te&&(c[ee]=ae)}return n.call(t,u,c)}function toJS(n,t,u){if(Array.isArray(n))return n.map((c,ee)=>toJS(c,String(ee),u));if(n&&typeof n.toJSON=="function"){if(!u||!hasAnchor(n))return n.toJSON(t,u);const c={aliasCount:0,count:1,res:void 0};u.anchors.set(n,c),u.onCreate=te=>{c.res=te,delete u.onCreate};const ee=n.toJSON(t,u);return u.onCreate&&u.onCreate(ee),ee}return typeof n=="bigint"&&!(u!=null&&u.keep)?Number(n):n}class NodeBase{constructor(t){Object.defineProperty(this,NODE_TYPE,{value:t})}clone(){const t=Object.create(Object.getPrototypeOf(this),Object.getOwnPropertyDescriptors(this));return this.range&&(t.range=this.range.slice()),t}toJS(t,{mapAsMap:u,maxAliasCount:c,onAnchor:ee,reviver:te}={}){if(!isDocument(t))throw new TypeError("A document argument is required");const ae={anchors:new Map,doc:t,keep:!0,mapAsMap:u===!0,mapKeyWarned:!1,maxAliasCount:typeof c=="number"?c:100},ne=toJS(this,"",ae);if(typeof ee=="function")for(const{count:oe,res:ie}of ae.anchors.values())ee(ie,oe);return typeof te=="function"?applyReviver(te,{"":ne},"",ne):ne}}class Alias extends NodeBase{constructor(t){super(ALIAS),this.source=t,Object.defineProperty(this,"tag",{set(){throw new Error("Alias nodes cannot have tags")}})}resolve(t){let u;return visit(t,{Node:(c,ee)=>{if(ee===this)return visit.BREAK;ee.anchor===this.source&&(u=ee)}}),u}toJSON(t,u){if(!u)return{source:this.source};const{anchors:c,doc:ee,maxAliasCount:te}=u,ae=this.resolve(ee);if(!ae){const oe=`Unresolved alias (the anchor must be set before the alias): ${this.source}`;throw new ReferenceError(oe)}let ne=c.get(ae);if(ne||(toJS(ae,null,u),ne=c.get(ae)),!ne||ne.res===void 0){const oe="This should not happen: Alias anchor was not resolved?";throw new ReferenceError(oe)}if(te>=0&&(ne.count+=1,ne.aliasCount===0&&(ne.aliasCount=getAliasCount(ee,ae,c)),ne.count*ne.aliasCount>te)){const oe="Excessive alias count indicates a resource exhaustion attack";throw new ReferenceError(oe)}return ne.res}toString(t,u,c){const ee=`*${this.source}`;if(t){if(anchorIsValid(this.source),t.options.verifyAliasOrder&&!t.anchors.has(this.source)){const te=`Unresolved alias (the anchor must be set before the alias): ${this.source}`;throw new Error(te)}if(t.implicitKey)return`${ee} `}return ee}}function getAliasCount(n,t,u){if(isAlias(t)){const c=t.resolve(n),ee=u&&c&&u.get(c);return ee?ee.count*ee.aliasCount:0}else if(isCollection(t)){let c=0;for(const ee of t.items){const te=getAliasCount(n,ee,u);te>c&&(c=te)}return c}else if(isPair(t)){const c=getAliasCount(n,t.key,u),ee=getAliasCount(n,t.value,u);return Math.max(c,ee)}return 1}const isScalarValue=n=>!n||typeof n!="function"&&typeof n!="object";class Scalar extends NodeBase{constructor(t){super(SCALAR$1),this.value=t}toJSON(t,u){return u!=null&&u.keep?this.value:toJS(this.value,t,u)}toString(){return String(this.value)}}Scalar.BLOCK_FOLDED="BLOCK_FOLDED";Scalar.BLOCK_LITERAL="BLOCK_LITERAL";Scalar.PLAIN="PLAIN";Scalar.QUOTE_DOUBLE="QUOTE_DOUBLE";Scalar.QUOTE_SINGLE="QUOTE_SINGLE";const defaultTagPrefix="tag:yaml.org,2002:";function findTagObject(n,t,u){if(t){const c=u.filter(te=>te.tag===t),ee=c.find(te=>!te.format)??c[0];if(!ee)throw new Error(`Tag ${t} not found`);return ee}return u.find(c=>{var ee;return((ee=c.identify)==null?void 0:ee.call(c,n))&&!c.format})}function createNode(n,t,u){var ue,le,ce;if(isDocument(n)&&(n=n.contents),isNode(n))return n;if(isPair(n)){const de=(le=(ue=u.schema[MAP$1]).createNode)==null?void 0:le.call(ue,u.schema,null,u);return de.items.push(n),de}(n instanceof String||n instanceof Number||n instanceof Boolean||typeof BigInt<"u"&&n instanceof BigInt)&&(n=n.valueOf());const{aliasDuplicateObjects:c,onAnchor:ee,onTagObj:te,schema:ae,sourceObjects:ne}=u;let oe;if(c&&n&&typeof n=="object"){if(oe=ne.get(n),oe)return oe.anchor||(oe.anchor=ee(n)),new Alias(oe.anchor);oe={anchor:null,node:null},ne.set(n,oe)}t!=null&&t.startsWith("!!")&&(t=defaultTagPrefix+t.slice(2));let ie=findTagObject(n,t,ae.tags);if(!ie){if(n&&typeof n.toJSON=="function"&&(n=n.toJSON()),!n||typeof n!="object"){const de=new Scalar(n);return oe&&(oe.node=de),de}ie=n instanceof Map?ae[MAP$1]:Symbol.iterator in Object(n)?ae[SEQ]:ae[MAP$1]}te&&(te(ie),delete u.onTagObj);const se=ie!=null&&ie.createNode?ie.createNode(u.schema,n,u):typeof((ce=ie==null?void 0:ie.nodeClass)==null?void 0:ce.from)=="function"?ie.nodeClass.from(u.schema,n,u):new Scalar(n);return t?se.tag=t:ie.default||(se.tag=ie.tag),oe&&(oe.node=se),se}function collectionFromPath(n,t,u){let c=u;for(let ee=t.length-1;ee>=0;--ee){const te=t[ee];if(typeof te=="number"&&Number.isInteger(te)&&te>=0){const ae=[];ae[te]=c,c=ae}else c=new Map([[te,c]])}return createNode(c,void 0,{aliasDuplicateObjects:!1,keepUndefined:!1,onAnchor:()=>{throw new Error("This should not happen, please report a bug.")},schema:n,sourceObjects:new Map})}const isEmptyPath=n=>n==null||typeof n=="object"&&!!n[Symbol.iterator]().next().done;class Collection extends NodeBase{constructor(t,u){super(t),Object.defineProperty(this,"schema",{value:u,configurable:!0,enumerable:!1,writable:!0})}clone(t){const u=Object.create(Object.getPrototypeOf(this),Object.getOwnPropertyDescriptors(this));return t&&(u.schema=t),u.items=u.items.map(c=>isNode(c)||isPair(c)?c.clone(t):c),this.range&&(u.range=this.range.slice()),u}addIn(t,u){if(isEmptyPath(t))this.add(u);else{const[c,...ee]=t,te=this.get(c,!0);if(isCollection(te))te.addIn(ee,u);else if(te===void 0&&this.schema)this.set(c,collectionFromPath(this.schema,ee,u));else throw new Error(`Expected YAML collection at ${c}. Remaining path: ${ee}`)}}deleteIn(t){const[u,...c]=t;if(c.length===0)return this.delete(u);const ee=this.get(u,!0);if(isCollection(ee))return ee.deleteIn(c);throw new Error(`Expected YAML collection at ${u}. Remaining path: ${c}`)}getIn(t,u){const[c,...ee]=t,te=this.get(c,!0);return ee.length===0?!u&&isScalar(te)?te.value:te:isCollection(te)?te.getIn(ee,u):void 0}hasAllNullValues(t){return this.items.every(u=>{if(!isPair(u))return!1;const c=u.value;return c==null||t&&isScalar(c)&&c.value==null&&!c.commentBefore&&!c.comment&&!c.tag})}hasIn(t){const[u,...c]=t;if(c.length===0)return this.has(u);const ee=this.get(u,!0);return isCollection(ee)?ee.hasIn(c):!1}setIn(t,u){const[c,...ee]=t;if(ee.length===0)this.set(c,u);else{const te=this.get(c,!0);if(isCollection(te))te.setIn(ee,u);else if(te===void 0&&this.schema)this.set(c,collectionFromPath(this.schema,ee,u));else throw new Error(`Expected YAML collection at ${c}. Remaining path: ${ee}`)}}}const stringifyComment=n=>n.replace(/^(?!$)(?: $)?/gm,"#");function indentComment(n,t){return/^\n+$/.test(n)?n.substring(1):t?n.replace(/^(?! *$)/gm,t):n}const lineComment=(n,t,u)=>n.endsWith(`
`)?indentComment(u,t):u.includes(`
`)?`
`+indentComment(u,t):(n.endsWith(" ")?"":" ")+u,FOLD_FLOW="flow",FOLD_BLOCK="block",FOLD_QUOTED="quoted";function foldFlowLines(n,t,u="flow",{indentAtStart:c,lineWidth:ee=80,minContentWidth:te=20,onFold:ae,onOverflow:ne}={}){if(!ee||ee<0)return n;ee<te&&(te=0);const oe=Math.max(1+te,1+ee-t.length);if(n.length<=oe)return n;const ie=[],se={};let ue=ee-t.length;typeof c=="number"&&(c>ee-Math.max(2,te)?ie.push(0):ue=ee-c);let le,ce,de=!1,fe=-1,pe=-1,me=-1;u===FOLD_BLOCK&&(fe=consumeMoreIndentedLines(n,fe,t.length),fe!==-1&&(ue=fe+oe));for(let De;De=n[fe+=1];){if(u===FOLD_QUOTED&&De==="\\"){switch(pe=fe,n[fe+1]){case"x":fe+=3;break;case"u":fe+=5;break;case"U":fe+=9;break;default:fe+=1}me=fe}if(De===`
`)u===FOLD_BLOCK&&(fe=consumeMoreIndentedLines(n,fe,t.length)),ue=fe+t.length+oe,le=void 0;else{if(De===" "&&ce&&ce!==" "&&ce!==`
`&&ce!=="	"){const Ce=n[fe+1];Ce&&Ce!==" "&&Ce!==`
`&&Ce!=="	"&&(le=fe)}if(fe>=ue)if(le)ie.push(le),ue=le+oe,le=void 0;else if(u===FOLD_QUOTED){for(;ce===" "||ce==="	";)ce=De,De=n[fe+=1],de=!0;const Ce=fe>me+1?fe-2:pe-1;if(se[Ce])return n;ie.push(Ce),se[Ce]=!0,ue=Ce+oe,le=void 0}else de=!0}ce=De}if(de&&ne&&ne(),ie.length===0)return n;ae&&ae();let ge=n.slice(0,ie[0]);for(let De=0;De<ie.length;++De){const Ce=ie[De],we=ie[De+1]||n.length;Ce===0?ge=`
${t}${n.slice(0,we)}`:(u===FOLD_QUOTED&&se[Ce]&&(ge+=`${n[Ce]}\\`),ge+=`
${t}${n.slice(Ce+1,we)}`)}return ge}function consumeMoreIndentedLines(n,t,u){let c=t,ee=t+1,te=n[ee];for(;te===" "||te==="	";)if(t<ee+u)te=n[++t];else{do te=n[++t];while(te&&te!==`
`);c=t,ee=t+1,te=n[ee]}return c}const getFoldOptions=(n,t)=>({indentAtStart:t?n.indent.length:n.indentAtStart,lineWidth:n.options.lineWidth,minContentWidth:n.options.minContentWidth}),containsDocumentMarker=n=>/^(%|---|\.\.\.)/m.test(n);function lineLengthOverLimit(n,t,u){if(!t||t<0)return!1;const c=t-u,ee=n.length;if(ee<=c)return!1;for(let te=0,ae=0;te<ee;++te)if(n[te]===`
`){if(te-ae>c)return!0;if(ae=te+1,ee-ae<=c)return!1}return!0}function doubleQuotedString(n,t){const u=JSON.stringify(n);if(t.options.doubleQuotedAsJSON)return u;const{implicitKey:c}=t,ee=t.options.doubleQuotedMinMultiLineLength,te=t.indent||(containsDocumentMarker(n)?"  ":"");let ae="",ne=0;for(let oe=0,ie=u[oe];ie;ie=u[++oe])if(ie===" "&&u[oe+1]==="\\"&&u[oe+2]==="n"&&(ae+=u.slice(ne,oe)+"\\ ",oe+=1,ne=oe,ie="\\"),ie==="\\")switch(u[oe+1]){case"u":{ae+=u.slice(ne,oe);const se=u.substr(oe+2,4);switch(se){case"0000":ae+="\\0";break;case"0007":ae+="\\a";break;case"000b":ae+="\\v";break;case"001b":ae+="\\e";break;case"0085":ae+="\\N";break;case"00a0":ae+="\\_";break;case"2028":ae+="\\L";break;case"2029":ae+="\\P";break;default:se.substr(0,2)==="00"?ae+="\\x"+se.substr(2):ae+=u.substr(oe,6)}oe+=5,ne=oe+1}break;case"n":if(c||u[oe+2]==='"'||u.length<ee)oe+=1;else{for(ae+=u.slice(ne,oe)+`

`;u[oe+2]==="\\"&&u[oe+3]==="n"&&u[oe+4]!=='"';)ae+=`
`,oe+=2;ae+=te,u[oe+2]===" "&&(ae+="\\"),oe+=1,ne=oe+1}break;default:oe+=1}return ae=ne?ae+u.slice(ne):u,c?ae:foldFlowLines(ae,te,FOLD_QUOTED,getFoldOptions(t,!1))}function singleQuotedString(n,t){if(t.options.singleQuote===!1||t.implicitKey&&n.includes(`
`)||/[ \t]\n|\n[ \t]/.test(n))return doubleQuotedString(n,t);const u=t.indent||(containsDocumentMarker(n)?"  ":""),c="'"+n.replace(/'/g,"''").replace(/\n+/g,`$&
${u}`)+"'";return t.implicitKey?c:foldFlowLines(c,u,FOLD_FLOW,getFoldOptions(t,!1))}function quotedString(n,t){const{singleQuote:u}=t.options;let c;if(u===!1)c=doubleQuotedString;else{const ee=n.includes('"'),te=n.includes("'");ee&&!te?c=singleQuotedString:te&&!ee?c=doubleQuotedString:c=u?singleQuotedString:doubleQuotedString}return c(n,t)}let blockEndNewlines;try{blockEndNewlines=new RegExp(`(^|(?<!
))
+(?!
|$)`,"g")}catch{blockEndNewlines=/\n+(?!\n|$)/g}function blockString({comment:n,type:t,value:u},c,ee,te){const{blockQuote:ae,commentString:ne,lineWidth:oe}=c.options;if(!ae||/\n[\t ]+$/.test(u)||/^\s*$/.test(u))return quotedString(u,c);const ie=c.indent||(c.forceBlockIndent||containsDocumentMarker(u)?"  ":""),se=ae==="literal"?!0:ae==="folded"||t===Scalar.BLOCK_FOLDED?!1:t===Scalar.BLOCK_LITERAL?!0:!lineLengthOverLimit(u,oe,ie.length);if(!u)return se?`|
`:`>
`;let ue,le;for(le=u.length;le>0;--le){const we=u[le-1];if(we!==`
`&&we!=="	"&&we!==" ")break}let ce=u.substring(le);const de=ce.indexOf(`
`);de===-1?ue="-":u===ce||de!==ce.length-1?(ue="+",te&&te()):ue="",ce&&(u=u.slice(0,-ce.length),ce[ce.length-1]===`
`&&(ce=ce.slice(0,-1)),ce=ce.replace(blockEndNewlines,`$&${ie}`));let fe=!1,pe,me=-1;for(pe=0;pe<u.length;++pe){const we=u[pe];if(we===" ")fe=!0;else if(we===`
`)me=pe;else break}let ge=u.substring(0,me<pe?me+1:pe);ge&&(u=u.substring(ge.length),ge=ge.replace(/\n+/g,`$&${ie}`));let Ce=(fe?ie?"2":"1":"")+ue;if(n&&(Ce+=" "+ne(n.replace(/ ?[\r\n]+/g," ")),ee&&ee()),!se){const we=u.replace(/\n+/g,`
$&`).replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g,"$1$2").replace(/\n+/g,`$&${ie}`);let xe=!1;const Re=getFoldOptions(c,!0);ae!=="folded"&&t!==Scalar.BLOCK_FOLDED&&(Re.onOverflow=()=>{xe=!0});const Be=foldFlowLines(`${ge}${we}${ce}`,ie,FOLD_BLOCK,Re);if(!xe)return`>${Ce}
${ie}${Be}`}return u=u.replace(/\n+/g,`$&${ie}`),`|${Ce}
${ie}${ge}${u}${ce}`}function plainString(n,t,u,c){const{type:ee,value:te}=n,{actualString:ae,implicitKey:ne,indent:oe,indentStep:ie,inFlow:se}=t;if(ne&&te.includes(`
`)||se&&/[[\]{},]/.test(te))return quotedString(te,t);if(!te||/^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(te))return ne||se||!te.includes(`
`)?quotedString(te,t):blockString(n,t,u,c);if(!ne&&!se&&ee!==Scalar.PLAIN&&te.includes(`
`))return blockString(n,t,u,c);if(containsDocumentMarker(te)){if(oe==="")return t.forceBlockIndent=!0,blockString(n,t,u,c);if(ne&&oe===ie)return quotedString(te,t)}const ue=te.replace(/\n+/g,`$&
${oe}`);if(ae){const le=fe=>{var pe;return fe.default&&fe.tag!=="tag:yaml.org,2002:str"&&((pe=fe.test)==null?void 0:pe.test(ue))},{compat:ce,tags:de}=t.doc.schema;if(de.some(le)||ce!=null&&ce.some(le))return quotedString(te,t)}return ne?ue:foldFlowLines(ue,oe,FOLD_FLOW,getFoldOptions(t,!1))}function stringifyString(n,t,u,c){const{implicitKey:ee,inFlow:te}=t,ae=typeof n.value=="string"?n:Object.assign({},n,{value:String(n.value)});let{type:ne}=n;ne!==Scalar.QUOTE_DOUBLE&&/[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ae.value)&&(ne=Scalar.QUOTE_DOUBLE);const oe=se=>{switch(se){case Scalar.BLOCK_FOLDED:case Scalar.BLOCK_LITERAL:return ee||te?quotedString(ae.value,t):blockString(ae,t,u,c);case Scalar.QUOTE_DOUBLE:return doubleQuotedString(ae.value,t);case Scalar.QUOTE_SINGLE:return singleQuotedString(ae.value,t);case Scalar.PLAIN:return plainString(ae,t,u,c);default:return null}};let ie=oe(ne);if(ie===null){const{defaultKeyType:se,defaultStringType:ue}=t.options,le=ee&&se||ue;if(ie=oe(le),ie===null)throw new Error(`Unsupported default string type ${le}`)}return ie}function createStringifyContext(n,t){const u=Object.assign({blockQuote:!0,commentString:stringifyComment,defaultKeyType:null,defaultStringType:"PLAIN",directives:null,doubleQuotedAsJSON:!1,doubleQuotedMinMultiLineLength:40,falseStr:"false",flowCollectionPadding:!0,indentSeq:!0,lineWidth:80,minContentWidth:20,nullStr:"null",simpleKeys:!1,singleQuote:null,trueStr:"true",verifyAliasOrder:!0},n.schema.toStringOptions,t);let c;switch(u.collectionStyle){case"block":c=!1;break;case"flow":c=!0;break;default:c=null}return{anchors:new Set,doc:n,flowCollectionPadding:u.flowCollectionPadding?" ":"",indent:"",indentStep:typeof u.indent=="number"?" ".repeat(u.indent):"  ",inFlow:c,options:u}}function getTagObject(n,t){var ee;if(t.tag){const te=n.filter(ae=>ae.tag===t.tag);if(te.length>0)return te.find(ae=>ae.format===t.format)??te[0]}let u,c;if(isScalar(t)){c=t.value;let te=n.filter(ae=>{var ne;return(ne=ae.identify)==null?void 0:ne.call(ae,c)});if(te.length>1){const ae=te.filter(ne=>ne.test);ae.length>0&&(te=ae)}u=te.find(ae=>ae.format===t.format)??te.find(ae=>!ae.format)}else c=t,u=n.find(te=>te.nodeClass&&c instanceof te.nodeClass);if(!u){const te=((ee=c==null?void 0:c.constructor)==null?void 0:ee.name)??typeof c;throw new Error(`Tag not resolved for ${te} value`)}return u}function stringifyProps(n,t,{anchors:u,doc:c}){if(!c.directives)return"";const ee=[],te=(isScalar(n)||isCollection(n))&&n.anchor;te&&anchorIsValid(te)&&(u.add(te),ee.push(`&${te}`));const ae=n.tag?n.tag:t.default?null:t.tag;return ae&&ee.push(c.directives.tagString(ae)),ee.join(" ")}function stringify$1(n,t,u,c){var oe;if(isPair(n))return n.toString(t,u,c);if(isAlias(n)){if(t.doc.directives)return n.toString(t);if((oe=t.resolvedAliases)!=null&&oe.has(n))throw new TypeError("Cannot stringify circular structure without alias nodes");t.resolvedAliases?t.resolvedAliases.add(n):t.resolvedAliases=new Set([n]),n=n.resolve(t.doc)}let ee;const te=isNode(n)?n:t.doc.createNode(n,{onTagObj:ie=>ee=ie});ee||(ee=getTagObject(t.doc.schema.tags,te));const ae=stringifyProps(te,ee,t);ae.length>0&&(t.indentAtStart=(t.indentAtStart??0)+ae.length+1);const ne=typeof ee.stringify=="function"?ee.stringify(te,t,u,c):isScalar(te)?stringifyString(te,t,u,c):te.toString(t,u,c);return ae?isScalar(te)||ne[0]==="{"||ne[0]==="["?`${ae} ${ne}`:`${ae}
${t.indent}${ne}`:ne}function stringifyPair({key:n,value:t},u,c,ee){const{allNullValues:te,doc:ae,indent:ne,indentStep:oe,options:{commentString:ie,indentSeq:se,simpleKeys:ue}}=u;let le=isNode(n)&&n.comment||null;if(ue){if(le)throw new Error("With simple keys, key nodes cannot have comments");if(isCollection(n)||!isNode(n)&&typeof n=="object"){const Re="With simple keys, collection cannot be used as a key value";throw new Error(Re)}}let ce=!ue&&(!n||le&&t==null&&!u.inFlow||isCollection(n)||(isScalar(n)?n.type===Scalar.BLOCK_FOLDED||n.type===Scalar.BLOCK_LITERAL:typeof n=="object"));u=Object.assign({},u,{allNullValues:!1,implicitKey:!ce&&(ue||!te),indent:ne+oe});let de=!1,fe=!1,pe=stringify$1(n,u,()=>de=!0,()=>fe=!0);if(!ce&&!u.inFlow&&pe.length>1024){if(ue)throw new Error("With simple keys, single line scalar must not span more than 1024 characters");ce=!0}if(u.inFlow){if(te||t==null)return de&&c&&c(),pe===""?"?":ce?`? ${pe}`:pe}else if(te&&!ue||t==null&&ce)return pe=`? ${pe}`,le&&!de?pe+=lineComment(pe,u.indent,ie(le)):fe&&ee&&ee(),pe;de&&(le=null),ce?(le&&(pe+=lineComment(pe,u.indent,ie(le))),pe=`? ${pe}
${ne}:`):(pe=`${pe}:`,le&&(pe+=lineComment(pe,u.indent,ie(le))));let me,ge,De;isNode(t)?(me=!!t.spaceBefore,ge=t.commentBefore,De=t.comment):(me=!1,ge=null,De=null,t&&typeof t=="object"&&(t=ae.createNode(t))),u.implicitKey=!1,!ce&&!le&&isScalar(t)&&(u.indentAtStart=pe.length+1),fe=!1,!se&&oe.length>=2&&!u.inFlow&&!ce&&isSeq(t)&&!t.flow&&!t.tag&&!t.anchor&&(u.indent=u.indent.substring(2));let Ce=!1;const we=stringify$1(t,u,()=>Ce=!0,()=>fe=!0);let xe=" ";if(le||me||ge){if(xe=me?`
`:"",ge){const Re=ie(ge);xe+=`
${indentComment(Re,u.indent)}`}we===""&&!u.inFlow?xe===`
`&&(xe=`

`):xe+=`
${u.indent}`}else if(!ce&&isCollection(t)){const Re=we[0],Be=we.indexOf(`
`),Se=Be!==-1,Te=u.inFlow??t.flow??t.items.length===0;if(Se||!Te){let Ae=!1;if(Se&&(Re==="&"||Re==="!")){let he=we.indexOf(" ");Re==="&"&&he!==-1&&he<Be&&we[he+1]==="!"&&(he=we.indexOf(" ",he+1)),(he===-1||Be<he)&&(Ae=!0)}Ae||(xe=`
${u.indent}`)}}else(we===""||we[0]===`
`)&&(xe="");return pe+=xe+we,u.inFlow?Ce&&c&&c():De&&!Ce?pe+=lineComment(pe,u.indent,ie(De)):fe&&ee&&ee(),pe}function warn(n,t){(n==="debug"||n==="warn")&&console.warn(t)}const MERGE_KEY="<<",merge={identify:n=>n===MERGE_KEY||typeof n=="symbol"&&n.description===MERGE_KEY,default:"key",tag:"tag:yaml.org,2002:merge",test:/^<<$/,resolve:()=>Object.assign(new Scalar(Symbol(MERGE_KEY)),{addToJSMap:addMergeToJSMap}),stringify:()=>MERGE_KEY},isMergeKey=(n,t)=>(merge.identify(t)||isScalar(t)&&(!t.type||t.type===Scalar.PLAIN)&&merge.identify(t.value))&&(n==null?void 0:n.doc.schema.tags.some(u=>u.tag===merge.tag&&u.default));function addMergeToJSMap(n,t,u){if(u=n&&isAlias(u)?u.resolve(n.doc):u,isSeq(u))for(const c of u.items)mergeValue(n,t,c);else if(Array.isArray(u))for(const c of u)mergeValue(n,t,c);else mergeValue(n,t,u)}function mergeValue(n,t,u){const c=n&&isAlias(u)?u.resolve(n.doc):u;if(!isMap(c))throw new Error("Merge sources must be maps or map aliases");const ee=c.toJSON(null,n,Map);for(const[te,ae]of ee)t instanceof Map?t.has(te)||t.set(te,ae):t instanceof Set?t.add(te):Object.prototype.hasOwnProperty.call(t,te)||Object.defineProperty(t,te,{value:ae,writable:!0,enumerable:!0,configurable:!0});return t}function addPairToJSMap(n,t,{key:u,value:c}){if(isNode(u)&&u.addToJSMap)u.addToJSMap(n,t,c);else if(isMergeKey(n,u))addMergeToJSMap(n,t,c);else{const ee=toJS(u,"",n);if(t instanceof Map)t.set(ee,toJS(c,ee,n));else if(t instanceof Set)t.add(ee);else{const te=stringifyKey(u,ee,n),ae=toJS(c,te,n);te in t?Object.defineProperty(t,te,{value:ae,writable:!0,enumerable:!0,configurable:!0}):t[te]=ae}}return t}function stringifyKey(n,t,u){if(t===null)return"";if(typeof t!="object")return String(t);if(isNode(n)&&(u!=null&&u.doc)){const c=createStringifyContext(u.doc,{});c.anchors=new Set;for(const te of u.anchors.keys())c.anchors.add(te.anchor);c.inFlow=!0,c.inStringifyKey=!0;const ee=n.toString(c);if(!u.mapKeyWarned){let te=JSON.stringify(ee);te.length>40&&(te=te.substring(0,36)+'..."'),warn(u.doc.options.logLevel,`Keys with collection values will be stringified due to JS Object restrictions: ${te}. Set mapAsMap: true to use object keys.`),u.mapKeyWarned=!0}return ee}return JSON.stringify(t)}function createPair(n,t,u){const c=createNode(n,void 0,u),ee=createNode(t,void 0,u);return new Pair(c,ee)}class Pair{constructor(t,u=null){Object.defineProperty(this,NODE_TYPE,{value:PAIR}),this.key=t,this.value=u}clone(t){let{key:u,value:c}=this;return isNode(u)&&(u=u.clone(t)),isNode(c)&&(c=c.clone(t)),new Pair(u,c)}toJSON(t,u){const c=u!=null&&u.mapAsMap?new Map:{};return addPairToJSMap(u,c,this)}toString(t,u,c){return t!=null&&t.doc?stringifyPair(this,t,u,c):JSON.stringify(this)}}function stringifyCollection(n,t,u){return(t.inFlow??n.flow?stringifyFlowCollection:stringifyBlockCollection)(n,t,u)}function stringifyBlockCollection({comment:n,items:t},u,{blockItemPrefix:c,flowChars:ee,itemIndent:te,onChompKeep:ae,onComment:ne}){const{indent:oe,options:{commentString:ie}}=u,se=Object.assign({},u,{indent:te,type:null});let ue=!1;const le=[];for(let de=0;de<t.length;++de){const fe=t[de];let pe=null;if(isNode(fe))!ue&&fe.spaceBefore&&le.push(""),addCommentBefore(u,le,fe.commentBefore,ue),fe.comment&&(pe=fe.comment);else if(isPair(fe)){const ge=isNode(fe.key)?fe.key:null;ge&&(!ue&&ge.spaceBefore&&le.push(""),addCommentBefore(u,le,ge.commentBefore,ue))}ue=!1;let me=stringify$1(fe,se,()=>pe=null,()=>ue=!0);pe&&(me+=lineComment(me,te,ie(pe))),ue&&pe&&(ue=!1),le.push(c+me)}let ce;if(le.length===0)ce=ee.start+ee.end;else{ce=le[0];for(let de=1;de<le.length;++de){const fe=le[de];ce+=fe?`
${oe}${fe}`:`
`}}return n?(ce+=`
`+indentComment(ie(n),oe),ne&&ne()):ue&&ae&&ae(),ce}function stringifyFlowCollection({items:n},t,{flowChars:u,itemIndent:c}){const{indent:ee,indentStep:te,flowCollectionPadding:ae,options:{commentString:ne}}=t;c+=te;const oe=Object.assign({},t,{indent:c,inFlow:!0,type:null});let ie=!1,se=0;const ue=[];for(let de=0;de<n.length;++de){const fe=n[de];let pe=null;if(isNode(fe))fe.spaceBefore&&ue.push(""),addCommentBefore(t,ue,fe.commentBefore,!1),fe.comment&&(pe=fe.comment);else if(isPair(fe)){const ge=isNode(fe.key)?fe.key:null;ge&&(ge.spaceBefore&&ue.push(""),addCommentBefore(t,ue,ge.commentBefore,!1),ge.comment&&(ie=!0));const De=isNode(fe.value)?fe.value:null;De?(De.comment&&(pe=De.comment),De.commentBefore&&(ie=!0)):fe.value==null&&(ge!=null&&ge.comment)&&(pe=ge.comment)}pe&&(ie=!0);let me=stringify$1(fe,oe,()=>pe=null);de<n.length-1&&(me+=","),pe&&(me+=lineComment(me,c,ne(pe))),!ie&&(ue.length>se||me.includes(`
`))&&(ie=!0),ue.push(me),se=ue.length}const{start:le,end:ce}=u;if(ue.length===0)return le+ce;if(!ie){const de=ue.reduce((fe,pe)=>fe+pe.length+2,2);ie=t.options.lineWidth>0&&de>t.options.lineWidth}if(ie){let de=le;for(const fe of ue)de+=fe?`
${te}${ee}${fe}`:`
`;return`${de}
${ee}${ce}`}else return`${le}${ae}${ue.join(" ")}${ae}${ce}`}function addCommentBefore({indent:n,options:{commentString:t}},u,c,ee){if(c&&ee&&(c=c.replace(/^\n+/,"")),c){const te=indentComment(t(c),n);u.push(te.trimStart())}}function findPair(n,t){const u=isScalar(t)?t.value:t;for(const c of n)if(isPair(c)&&(c.key===t||c.key===u||isScalar(c.key)&&c.key.value===u))return c}class YAMLMap extends Collection{static get tagName(){return"tag:yaml.org,2002:map"}constructor(t){super(MAP$1,t),this.items=[]}static from(t,u,c){const{keepUndefined:ee,replacer:te}=c,ae=new this(t),ne=(oe,ie)=>{if(typeof te=="function")ie=te.call(u,oe,ie);else if(Array.isArray(te)&&!te.includes(oe))return;(ie!==void 0||ee)&&ae.items.push(createPair(oe,ie,c))};if(u instanceof Map)for(const[oe,ie]of u)ne(oe,ie);else if(u&&typeof u=="object")for(const oe of Object.keys(u))ne(oe,u[oe]);return typeof t.sortMapEntries=="function"&&ae.items.sort(t.sortMapEntries),ae}add(t,u){var ae;let c;isPair(t)?c=t:!t||typeof t!="object"||!("key"in t)?c=new Pair(t,t==null?void 0:t.value):c=new Pair(t.key,t.value);const ee=findPair(this.items,c.key),te=(ae=this.schema)==null?void 0:ae.sortMapEntries;if(ee){if(!u)throw new Error(`Key ${c.key} already set`);isScalar(ee.value)&&isScalarValue(c.value)?ee.value.value=c.value:ee.value=c.value}else if(te){const ne=this.items.findIndex(oe=>te(c,oe)<0);ne===-1?this.items.push(c):this.items.splice(ne,0,c)}else this.items.push(c)}delete(t){const u=findPair(this.items,t);return u?this.items.splice(this.items.indexOf(u),1).length>0:!1}get(t,u){const c=findPair(this.items,t),ee=c==null?void 0:c.value;return(!u&&isScalar(ee)?ee.value:ee)??void 0}has(t){return!!findPair(this.items,t)}set(t,u){this.add(new Pair(t,u),!0)}toJSON(t,u,c){const ee=c?new c:u!=null&&u.mapAsMap?new Map:{};u!=null&&u.onCreate&&u.onCreate(ee);for(const te of this.items)addPairToJSMap(u,ee,te);return ee}toString(t,u,c){if(!t)return JSON.stringify(this);for(const ee of this.items)if(!isPair(ee))throw new Error(`Map items must all be pairs; found ${JSON.stringify(ee)} instead`);return!t.allNullValues&&this.hasAllNullValues(!1)&&(t=Object.assign({},t,{allNullValues:!0})),stringifyCollection(this,t,{blockItemPrefix:"",flowChars:{start:"{",end:"}"},itemIndent:t.indent||"",onChompKeep:c,onComment:u})}}const map$1={collection:"map",default:!0,nodeClass:YAMLMap,tag:"tag:yaml.org,2002:map",resolve(n,t){return isMap(n)||t("Expected a mapping for this tag"),n},createNode:(n,t,u)=>YAMLMap.from(n,t,u)};class YAMLSeq extends Collection{static get tagName(){return"tag:yaml.org,2002:seq"}constructor(t){super(SEQ,t),this.items=[]}add(t){this.items.push(t)}delete(t){const u=asItemIndex(t);return typeof u!="number"?!1:this.items.splice(u,1).length>0}get(t,u){const c=asItemIndex(t);if(typeof c!="number")return;const ee=this.items[c];return!u&&isScalar(ee)?ee.value:ee}has(t){const u=asItemIndex(t);return typeof u=="number"&&u<this.items.length}set(t,u){const c=asItemIndex(t);if(typeof c!="number")throw new Error(`Expected a valid index, not ${t}.`);const ee=this.items[c];isScalar(ee)&&isScalarValue(u)?ee.value=u:this.items[c]=u}toJSON(t,u){const c=[];u!=null&&u.onCreate&&u.onCreate(c);let ee=0;for(const te of this.items)c.push(toJS(te,String(ee++),u));return c}toString(t,u,c){return t?stringifyCollection(this,t,{blockItemPrefix:"- ",flowChars:{start:"[",end:"]"},itemIndent:(t.indent||"")+"  ",onChompKeep:c,onComment:u}):JSON.stringify(this)}static from(t,u,c){const{replacer:ee}=c,te=new this(t);if(u&&Symbol.iterator in Object(u)){let ae=0;for(let ne of u){if(typeof ee=="function"){const oe=u instanceof Set?ne:String(ae++);ne=ee.call(u,oe,ne)}te.items.push(createNode(ne,void 0,c))}}return te}}function asItemIndex(n){let t=isScalar(n)?n.value:n;return t&&typeof t=="string"&&(t=Number(t)),typeof t=="number"&&Number.isInteger(t)&&t>=0?t:null}const seq={collection:"seq",default:!0,nodeClass:YAMLSeq,tag:"tag:yaml.org,2002:seq",resolve(n,t){return isSeq(n)||t("Expected a sequence for this tag"),n},createNode:(n,t,u)=>YAMLSeq.from(n,t,u)},string$1={identify:n=>typeof n=="string",default:!0,tag:"tag:yaml.org,2002:str",resolve:n=>n,stringify(n,t,u,c){return t=Object.assign({actualString:!0},t),stringifyString(n,t,u,c)}},nullTag={identify:n=>n==null,createNode:()=>new Scalar(null),default:!0,tag:"tag:yaml.org,2002:null",test:/^(?:~|[Nn]ull|NULL)?$/,resolve:()=>new Scalar(null),stringify:({source:n},t)=>typeof n=="string"&&nullTag.test.test(n)?n:t.options.nullStr},boolTag={identify:n=>typeof n=="boolean",default:!0,tag:"tag:yaml.org,2002:bool",test:/^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,resolve:n=>new Scalar(n[0]==="t"||n[0]==="T"),stringify({source:n,value:t},u){if(n&&boolTag.test.test(n)){const c=n[0]==="t"||n[0]==="T";if(t===c)return n}return t?u.options.trueStr:u.options.falseStr}};function stringifyNumber({format:n,minFractionDigits:t,tag:u,value:c}){if(typeof c=="bigint")return String(c);const ee=typeof c=="number"?c:Number(c);if(!isFinite(ee))return isNaN(ee)?".nan":ee<0?"-.inf":".inf";let te=JSON.stringify(c);if(!n&&t&&(!u||u==="tag:yaml.org,2002:float")&&/^\d/.test(te)){let ae=te.indexOf(".");ae<0&&(ae=te.length,te+=".");let ne=t-(te.length-ae-1);for(;ne-- >0;)te+="0"}return te}const floatNaN$1={identify:n=>typeof n=="number",default:!0,tag:"tag:yaml.org,2002:float",test:/^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,resolve:n=>n.slice(-3).toLowerCase()==="nan"?NaN:n[0]==="-"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,stringify:stringifyNumber},floatExp$1={identify:n=>typeof n=="number",default:!0,tag:"tag:yaml.org,2002:float",format:"EXP",test:/^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,resolve:n=>parseFloat(n),stringify(n){const t=Number(n.value);return isFinite(t)?t.toExponential():stringifyNumber(n)}},float$1={identify:n=>typeof n=="number",default:!0,tag:"tag:yaml.org,2002:float",test:/^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,resolve(n){const t=new Scalar(parseFloat(n)),u=n.indexOf(".");return u!==-1&&n[n.length-1]==="0"&&(t.minFractionDigits=n.length-u-1),t},stringify:stringifyNumber},intIdentify$2=n=>typeof n=="bigint"||Number.isInteger(n),intResolve$1=(n,t,u,{intAsBigInt:c})=>c?BigInt(n):parseInt(n.substring(t),u);function intStringify$1(n,t,u){const{value:c}=n;return intIdentify$2(c)&&c>=0?u+c.toString(t):stringifyNumber(n)}const intOct$1={identify:n=>intIdentify$2(n)&&n>=0,default:!0,tag:"tag:yaml.org,2002:int",format:"OCT",test:/^0o[0-7]+$/,resolve:(n,t,u)=>intResolve$1(n,2,8,u),stringify:n=>intStringify$1(n,8,"0o")},int$1={identify:intIdentify$2,default:!0,tag:"tag:yaml.org,2002:int",test:/^[-+]?[0-9]+$/,resolve:(n,t,u)=>intResolve$1(n,0,10,u),stringify:stringifyNumber},intHex$1={identify:n=>intIdentify$2(n)&&n>=0,default:!0,tag:"tag:yaml.org,2002:int",format:"HEX",test:/^0x[0-9a-fA-F]+$/,resolve:(n,t,u)=>intResolve$1(n,2,16,u),stringify:n=>intStringify$1(n,16,"0x")},schema$2=[map$1,seq,string$1,nullTag,boolTag,intOct$1,int$1,intHex$1,floatNaN$1,floatExp$1,float$1];function intIdentify$1(n){return typeof n=="bigint"||Number.isInteger(n)}const stringifyJSON=({value:n})=>JSON.stringify(n),jsonScalars=[{identify:n=>typeof n=="string",default:!0,tag:"tag:yaml.org,2002:str",resolve:n=>n,stringify:stringifyJSON},{identify:n=>n==null,createNode:()=>new Scalar(null),default:!0,tag:"tag:yaml.org,2002:null",test:/^null$/,resolve:()=>null,stringify:stringifyJSON},{identify:n=>typeof n=="boolean",default:!0,tag:"tag:yaml.org,2002:bool",test:/^true$|^false$/,resolve:n=>n==="true",stringify:stringifyJSON},{identify:intIdentify$1,default:!0,tag:"tag:yaml.org,2002:int",test:/^-?(?:0|[1-9][0-9]*)$/,resolve:(n,t,{intAsBigInt:u})=>u?BigInt(n):parseInt(n,10),stringify:({value:n})=>intIdentify$1(n)?n.toString():JSON.stringify(n)},{identify:n=>typeof n=="number",default:!0,tag:"tag:yaml.org,2002:float",test:/^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,resolve:n=>parseFloat(n),stringify:stringifyJSON}],jsonError={default:!0,tag:"",test:/^/,resolve(n,t){return t(`Unresolved plain scalar ${JSON.stringify(n)}`),n}},schema$1=[map$1,seq].concat(jsonScalars,jsonError),binary={identify:n=>n instanceof Uint8Array,default:!1,tag:"tag:yaml.org,2002:binary",resolve(n,t){if(typeof atob=="function"){const u=atob(n.replace(/[\n\r]/g,"")),c=new Uint8Array(u.length);for(let ee=0;ee<u.length;++ee)c[ee]=u.charCodeAt(ee);return c}else return t("This environment does not support reading binary tags; either Buffer or atob is required"),n},stringify({comment:n,type:t,value:u},c,ee,te){const ae=u;let ne;if(typeof btoa=="function"){let oe="";for(let ie=0;ie<ae.length;++ie)oe+=String.fromCharCode(ae[ie]);ne=btoa(oe)}else throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");if(t||(t=Scalar.BLOCK_LITERAL),t!==Scalar.QUOTE_DOUBLE){const oe=Math.max(c.options.lineWidth-c.indent.length,c.options.minContentWidth),ie=Math.ceil(ne.length/oe),se=new Array(ie);for(let ue=0,le=0;ue<ie;++ue,le+=oe)se[ue]=ne.substr(le,oe);ne=se.join(t===Scalar.BLOCK_LITERAL?`
`:" ")}return stringifyString({comment:n,type:t,value:ne},c,ee,te)}};function resolvePairs(n,t){if(isSeq(n))for(let u=0;u<n.items.length;++u){let c=n.items[u];if(!isPair(c)){if(isMap(c)){c.items.length>1&&t("Each pair must have its own sequence indicator");const ee=c.items[0]||new Pair(new Scalar(null));if(c.commentBefore&&(ee.key.commentBefore=ee.key.commentBefore?`${c.commentBefore}
${ee.key.commentBefore}`:c.commentBefore),c.comment){const te=ee.value??ee.key;te.comment=te.comment?`${c.comment}
${te.comment}`:c.comment}c=ee}n.items[u]=isPair(c)?c:new Pair(c)}}else t("Expected a sequence for this tag");return n}function createPairs(n,t,u){const{replacer:c}=u,ee=new YAMLSeq(n);ee.tag="tag:yaml.org,2002:pairs";let te=0;if(t&&Symbol.iterator in Object(t))for(let ae of t){typeof c=="function"&&(ae=c.call(t,String(te++),ae));let ne,oe;if(Array.isArray(ae))if(ae.length===2)ne=ae[0],oe=ae[1];else throw new TypeError(`Expected [key, value] tuple: ${ae}`);else if(ae&&ae instanceof Object){const ie=Object.keys(ae);if(ie.length===1)ne=ie[0],oe=ae[ne];else throw new TypeError(`Expected tuple with one key, not ${ie.length} keys`)}else ne=ae;ee.items.push(createPair(ne,oe,u))}return ee}const pairs={collection:"seq",default:!1,tag:"tag:yaml.org,2002:pairs",resolve:resolvePairs,createNode:createPairs};class YAMLOMap extends YAMLSeq{constructor(){super(),this.add=YAMLMap.prototype.add.bind(this),this.delete=YAMLMap.prototype.delete.bind(this),this.get=YAMLMap.prototype.get.bind(this),this.has=YAMLMap.prototype.has.bind(this),this.set=YAMLMap.prototype.set.bind(this),this.tag=YAMLOMap.tag}toJSON(t,u){if(!u)return super.toJSON(t);const c=new Map;u!=null&&u.onCreate&&u.onCreate(c);for(const ee of this.items){let te,ae;if(isPair(ee)?(te=toJS(ee.key,"",u),ae=toJS(ee.value,te,u)):te=toJS(ee,"",u),c.has(te))throw new Error("Ordered maps must not include duplicate keys");c.set(te,ae)}return c}static from(t,u,c){const ee=createPairs(t,u,c),te=new this;return te.items=ee.items,te}}YAMLOMap.tag="tag:yaml.org,2002:omap";const omap={collection:"seq",identify:n=>n instanceof Map,nodeClass:YAMLOMap,default:!1,tag:"tag:yaml.org,2002:omap",resolve(n,t){const u=resolvePairs(n,t),c=[];for(const{key:ee}of u.items)isScalar(ee)&&(c.includes(ee.value)?t(`Ordered maps must not include duplicate keys: ${ee.value}`):c.push(ee.value));return Object.assign(new YAMLOMap,u)},createNode:(n,t,u)=>YAMLOMap.from(n,t,u)};function boolStringify({value:n,source:t},u){return t&&(n?trueTag:falseTag).test.test(t)?t:n?u.options.trueStr:u.options.falseStr}const trueTag={identify:n=>n===!0,default:!0,tag:"tag:yaml.org,2002:bool",test:/^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,resolve:()=>new Scalar(!0),stringify:boolStringify},falseTag={identify:n=>n===!1,default:!0,tag:"tag:yaml.org,2002:bool",test:/^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/,resolve:()=>new Scalar(!1),stringify:boolStringify},floatNaN={identify:n=>typeof n=="number",default:!0,tag:"tag:yaml.org,2002:float",test:/^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,resolve:n=>n.slice(-3).toLowerCase()==="nan"?NaN:n[0]==="-"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,stringify:stringifyNumber},floatExp={identify:n=>typeof n=="number",default:!0,tag:"tag:yaml.org,2002:float",format:"EXP",test:/^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,resolve:n=>parseFloat(n.replace(/_/g,"")),stringify(n){const t=Number(n.value);return isFinite(t)?t.toExponential():stringifyNumber(n)}},float={identify:n=>typeof n=="number",default:!0,tag:"tag:yaml.org,2002:float",test:/^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,resolve(n){const t=new Scalar(parseFloat(n.replace(/_/g,""))),u=n.indexOf(".");if(u!==-1){const c=n.substring(u+1).replace(/_/g,"");c[c.length-1]==="0"&&(t.minFractionDigits=c.length)}return t},stringify:stringifyNumber},intIdentify=n=>typeof n=="bigint"||Number.isInteger(n);function intResolve(n,t,u,{intAsBigInt:c}){const ee=n[0];if((ee==="-"||ee==="+")&&(t+=1),n=n.substring(t).replace(/_/g,""),c){switch(u){case 2:n=`0b${n}`;break;case 8:n=`0o${n}`;break;case 16:n=`0x${n}`;break}const ae=BigInt(n);return ee==="-"?BigInt(-1)*ae:ae}const te=parseInt(n,u);return ee==="-"?-1*te:te}function intStringify(n,t,u){const{value:c}=n;if(intIdentify(c)){const ee=c.toString(t);return c<0?"-"+u+ee.substr(1):u+ee}return stringifyNumber(n)}const intBin={identify:intIdentify,default:!0,tag:"tag:yaml.org,2002:int",format:"BIN",test:/^[-+]?0b[0-1_]+$/,resolve:(n,t,u)=>intResolve(n,2,2,u),stringify:n=>intStringify(n,2,"0b")},intOct={identify:intIdentify,default:!0,tag:"tag:yaml.org,2002:int",format:"OCT",test:/^[-+]?0[0-7_]+$/,resolve:(n,t,u)=>intResolve(n,1,8,u),stringify:n=>intStringify(n,8,"0")},int={identify:intIdentify,default:!0,tag:"tag:yaml.org,2002:int",test:/^[-+]?[0-9][0-9_]*$/,resolve:(n,t,u)=>intResolve(n,0,10,u),stringify:stringifyNumber},intHex={identify:intIdentify,default:!0,tag:"tag:yaml.org,2002:int",format:"HEX",test:/^[-+]?0x[0-9a-fA-F_]+$/,resolve:(n,t,u)=>intResolve(n,2,16,u),stringify:n=>intStringify(n,16,"0x")};class YAMLSet extends YAMLMap{constructor(t){super(t),this.tag=YAMLSet.tag}add(t){let u;isPair(t)?u=t:t&&typeof t=="object"&&"key"in t&&"value"in t&&t.value===null?u=new Pair(t.key,null):u=new Pair(t,null),findPair(this.items,u.key)||this.items.push(u)}get(t,u){const c=findPair(this.items,t);return!u&&isPair(c)?isScalar(c.key)?c.key.value:c.key:c}set(t,u){if(typeof u!="boolean")throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof u}`);const c=findPair(this.items,t);c&&!u?this.items.splice(this.items.indexOf(c),1):!c&&u&&this.items.push(new Pair(t))}toJSON(t,u){return super.toJSON(t,u,Set)}toString(t,u,c){if(!t)return JSON.stringify(this);if(this.hasAllNullValues(!0))return super.toString(Object.assign({},t,{allNullValues:!0}),u,c);throw new Error("Set items must all have null values")}static from(t,u,c){const{replacer:ee}=c,te=new this(t);if(u&&Symbol.iterator in Object(u))for(let ae of u)typeof ee=="function"&&(ae=ee.call(u,ae,ae)),te.items.push(createPair(ae,null,c));return te}}YAMLSet.tag="tag:yaml.org,2002:set";const set$1={collection:"map",identify:n=>n instanceof Set,nodeClass:YAMLSet,default:!1,tag:"tag:yaml.org,2002:set",createNode:(n,t,u)=>YAMLSet.from(n,t,u),resolve(n,t){if(isMap(n)){if(n.hasAllNullValues(!0))return Object.assign(new YAMLSet,n);t("Set items must all have null values")}else t("Expected a mapping for this tag");return n}};function parseSexagesimal(n,t){const u=n[0],c=u==="-"||u==="+"?n.substring(1):n,ee=ae=>t?BigInt(ae):Number(ae),te=c.replace(/_/g,"").split(":").reduce((ae,ne)=>ae*ee(60)+ee(ne),ee(0));return u==="-"?ee(-1)*te:te}function stringifySexagesimal(n){let{value:t}=n,u=ae=>ae;if(typeof t=="bigint")u=ae=>BigInt(ae);else if(isNaN(t)||!isFinite(t))return stringifyNumber(n);let c="";t<0&&(c="-",t*=u(-1));const ee=u(60),te=[t%ee];return t<60?te.unshift(0):(t=(t-te[0])/ee,te.unshift(t%ee),t>=60&&(t=(t-te[0])/ee,te.unshift(t))),c+te.map(ae=>String(ae).padStart(2,"0")).join(":").replace(/000000\d*$/,"")}const intTime={identify:n=>typeof n=="bigint"||Number.isInteger(n),default:!0,tag:"tag:yaml.org,2002:int",format:"TIME",test:/^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,resolve:(n,t,{intAsBigInt:u})=>parseSexagesimal(n,u),stringify:stringifySexagesimal},floatTime={identify:n=>typeof n=="number",default:!0,tag:"tag:yaml.org,2002:float",format:"TIME",test:/^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,resolve:n=>parseSexagesimal(n,!1),stringify:stringifySexagesimal},timestamp={identify:n=>n instanceof Date,default:!0,tag:"tag:yaml.org,2002:timestamp",test:RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?$"),resolve(n){const t=n.match(timestamp.test);if(!t)throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");const[,u,c,ee,te,ae,ne]=t.map(Number),oe=t[7]?Number((t[7]+"00").substr(1,3)):0;let ie=Date.UTC(u,c-1,ee,te||0,ae||0,ne||0,oe);const se=t[8];if(se&&se!=="Z"){let ue=parseSexagesimal(se,!1);Math.abs(ue)<30&&(ue*=60),ie-=6e4*ue}return new Date(ie)},stringify:({value:n})=>n.toISOString().replace(/(T00:00:00)?\.000Z$/,"")},schema=[map$1,seq,string$1,nullTag,trueTag,falseTag,intBin,intOct,int,intHex,floatNaN,floatExp,float,binary,merge,omap,pairs,set$1,intTime,floatTime,timestamp],schemas=new Map([["core",schema$2],["failsafe",[map$1,seq,string$1]],["json",schema$1],["yaml11",schema],["yaml-1.1",schema]]),tagsByName={binary,bool:boolTag,float:float$1,floatExp:floatExp$1,floatNaN:floatNaN$1,floatTime,int:int$1,intHex:intHex$1,intOct:intOct$1,intTime,map:map$1,merge,null:nullTag,omap,pairs,seq,set:set$1,timestamp},coreKnownTags={"tag:yaml.org,2002:binary":binary,"tag:yaml.org,2002:merge":merge,"tag:yaml.org,2002:omap":omap,"tag:yaml.org,2002:pairs":pairs,"tag:yaml.org,2002:set":set$1,"tag:yaml.org,2002:timestamp":timestamp};function getTags(n,t,u){const c=schemas.get(t);if(c&&!n)return u&&!c.includes(merge)?c.concat(merge):c.slice();let ee=c;if(!ee)if(Array.isArray(n))ee=[];else{const te=Array.from(schemas.keys()).filter(ae=>ae!=="yaml11").map(ae=>JSON.stringify(ae)).join(", ");throw new Error(`Unknown schema "${t}"; use one of ${te} or define customTags array`)}if(Array.isArray(n))for(const te of n)ee=ee.concat(te);else typeof n=="function"&&(ee=n(ee.slice()));return u&&(ee=ee.concat(merge)),ee.reduce((te,ae)=>{const ne=typeof ae=="string"?tagsByName[ae]:ae;if(!ne){const oe=JSON.stringify(ae),ie=Object.keys(tagsByName).map(se=>JSON.stringify(se)).join(", ");throw new Error(`Unknown custom tag ${oe}; use one of ${ie}`)}return te.includes(ne)||te.push(ne),te},[])}const sortMapEntriesByKey=(n,t)=>n.key<t.key?-1:n.key>t.key?1:0;class Schema{constructor({compat:t,customTags:u,merge:c,resolveKnownTags:ee,schema:te,sortMapEntries:ae,toStringDefaults:ne}){this.compat=Array.isArray(t)?getTags(t,"compat"):t?getTags(null,t):null,this.name=typeof te=="string"&&te||"core",this.knownTags=ee?coreKnownTags:{},this.tags=getTags(u,this.name,c),this.toStringOptions=ne??null,Object.defineProperty(this,MAP$1,{value:map$1}),Object.defineProperty(this,SCALAR$1,{value:string$1}),Object.defineProperty(this,SEQ,{value:seq}),this.sortMapEntries=typeof ae=="function"?ae:ae===!0?sortMapEntriesByKey:null}clone(){const t=Object.create(Schema.prototype,Object.getOwnPropertyDescriptors(this));return t.tags=this.tags.slice(),t}}function stringifyDocument(n,t){var oe;const u=[];let c=t.directives===!0;if(t.directives!==!1&&n.directives){const ie=n.directives.toString(n);ie?(u.push(ie),c=!0):n.directives.docStart&&(c=!0)}c&&u.push("---");const ee=createStringifyContext(n,t),{commentString:te}=ee.options;if(n.commentBefore){u.length!==1&&u.unshift("");const ie=te(n.commentBefore);u.unshift(indentComment(ie,""))}let ae=!1,ne=null;if(n.contents){if(isNode(n.contents)){if(n.contents.spaceBefore&&c&&u.push(""),n.contents.commentBefore){const ue=te(n.contents.commentBefore);u.push(indentComment(ue,""))}ee.forceBlockIndent=!!n.comment,ne=n.contents.comment}const ie=ne?void 0:()=>ae=!0;let se=stringify$1(n.contents,ee,()=>ne=null,ie);ne&&(se+=lineComment(se,"",te(ne))),(se[0]==="|"||se[0]===">")&&u[u.length-1]==="---"?u[u.length-1]=`--- ${se}`:u.push(se)}else u.push(stringify$1(n.contents,ee));if((oe=n.directives)!=null&&oe.docEnd)if(n.comment){const ie=te(n.comment);ie.includes(`
`)?(u.push("..."),u.push(indentComment(ie,""))):u.push(`... ${ie}`)}else u.push("...");else{let ie=n.comment;ie&&ae&&(ie=ie.replace(/^\n+/,"")),ie&&((!ae||ne)&&u[u.length-1]!==""&&u.push(""),u.push(indentComment(te(ie),"")))}return u.join(`
`)+`
`}class Document{constructor(t,u,c){this.commentBefore=null,this.comment=null,this.errors=[],this.warnings=[],Object.defineProperty(this,NODE_TYPE,{value:DOC});let ee=null;typeof u=="function"||Array.isArray(u)?ee=u:c===void 0&&u&&(c=u,u=void 0);const te=Object.assign({intAsBigInt:!1,keepSourceTokens:!1,logLevel:"warn",prettyErrors:!0,strict:!0,stringKeys:!1,uniqueKeys:!0,version:"1.2"},c);this.options=te;let{version:ae}=te;c!=null&&c._directives?(this.directives=c._directives.atDocument(),this.directives.yaml.explicit&&(ae=this.directives.yaml.version)):this.directives=new Directives({version:ae}),this.setSchema(ae,c),this.contents=t===void 0?null:this.createNode(t,ee,c)}clone(){const t=Object.create(Document.prototype,{[NODE_TYPE]:{value:DOC}});return t.commentBefore=this.commentBefore,t.comment=this.comment,t.errors=this.errors.slice(),t.warnings=this.warnings.slice(),t.options=Object.assign({},this.options),this.directives&&(t.directives=this.directives.clone()),t.schema=this.schema.clone(),t.contents=isNode(this.contents)?this.contents.clone(t.schema):this.contents,this.range&&(t.range=this.range.slice()),t}add(t){assertCollection(this.contents)&&this.contents.add(t)}addIn(t,u){assertCollection(this.contents)&&this.contents.addIn(t,u)}createAlias(t,u){if(!t.anchor){const c=anchorNames(this);t.anchor=!u||c.has(u)?findNewAnchor(u||"a",c):u}return new Alias(t.anchor)}createNode(t,u,c){let ee;if(typeof u=="function")t=u.call({"":t},"",t),ee=u;else if(Array.isArray(u)){const pe=ge=>typeof ge=="number"||ge instanceof String||ge instanceof Number,me=u.filter(pe).map(String);me.length>0&&(u=u.concat(me)),ee=u}else c===void 0&&u&&(c=u,u=void 0);const{aliasDuplicateObjects:te,anchorPrefix:ae,flow:ne,keepUndefined:oe,onTagObj:ie,tag:se}=c??{},{onAnchor:ue,setAnchors:le,sourceObjects:ce}=createNodeAnchors(this,ae||"a"),de={aliasDuplicateObjects:te??!0,keepUndefined:oe??!1,onAnchor:ue,onTagObj:ie,replacer:ee,schema:this.schema,sourceObjects:ce},fe=createNode(t,se,de);return ne&&isCollection(fe)&&(fe.flow=!0),le(),fe}createPair(t,u,c={}){const ee=this.createNode(t,null,c),te=this.createNode(u,null,c);return new Pair(ee,te)}delete(t){return assertCollection(this.contents)?this.contents.delete(t):!1}deleteIn(t){return isEmptyPath(t)?this.contents==null?!1:(this.contents=null,!0):assertCollection(this.contents)?this.contents.deleteIn(t):!1}get(t,u){return isCollection(this.contents)?this.contents.get(t,u):void 0}getIn(t,u){return isEmptyPath(t)?!u&&isScalar(this.contents)?this.contents.value:this.contents:isCollection(this.contents)?this.contents.getIn(t,u):void 0}has(t){return isCollection(this.contents)?this.contents.has(t):!1}hasIn(t){return isEmptyPath(t)?this.contents!==void 0:isCollection(this.contents)?this.contents.hasIn(t):!1}set(t,u){this.contents==null?this.contents=collectionFromPath(this.schema,[t],u):assertCollection(this.contents)&&this.contents.set(t,u)}setIn(t,u){isEmptyPath(t)?this.contents=u:this.contents==null?this.contents=collectionFromPath(this.schema,Array.from(t),u):assertCollection(this.contents)&&this.contents.setIn(t,u)}setSchema(t,u={}){typeof t=="number"&&(t=String(t));let c;switch(t){case"1.1":this.directives?this.directives.yaml.version="1.1":this.directives=new Directives({version:"1.1"}),c={resolveKnownTags:!1,schema:"yaml-1.1"};break;case"1.2":case"next":this.directives?this.directives.yaml.version=t:this.directives=new Directives({version:t}),c={resolveKnownTags:!0,schema:"core"};break;case null:this.directives&&delete this.directives,c=null;break;default:{const ee=JSON.stringify(t);throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${ee}`)}}if(u.schema instanceof Object)this.schema=u.schema;else if(c)this.schema=new Schema(Object.assign(c,u));else throw new Error("With a null YAML version, the { schema: Schema } option is required")}toJS({json:t,jsonArg:u,mapAsMap:c,maxAliasCount:ee,onAnchor:te,reviver:ae}={}){const ne={anchors:new Map,doc:this,keep:!t,mapAsMap:c===!0,mapKeyWarned:!1,maxAliasCount:typeof ee=="number"?ee:100},oe=toJS(this.contents,u??"",ne);if(typeof te=="function")for(const{count:ie,res:se}of ne.anchors.values())te(se,ie);return typeof ae=="function"?applyReviver(ae,{"":oe},"",oe):oe}toJSON(t,u){return this.toJS({json:!0,jsonArg:t,mapAsMap:!1,onAnchor:u})}toString(t={}){if(this.errors.length>0)throw new Error("Document with errors cannot be stringified");if("indent"in t&&(!Number.isInteger(t.indent)||Number(t.indent)<=0)){const u=JSON.stringify(t.indent);throw new Error(`"indent" option must be a positive integer, not ${u}`)}return stringifyDocument(this,t)}}function assertCollection(n){if(isCollection(n))return!0;throw new Error("Expected a YAML collection as document contents")}class YAMLError extends Error{constructor(t,u,c,ee){super(),this.name=t,this.code=c,this.message=ee,this.pos=u}}class YAMLParseError extends YAMLError{constructor(t,u,c){super("YAMLParseError",t,u,c)}}class YAMLWarning extends YAMLError{constructor(t,u,c){super("YAMLWarning",t,u,c)}}const prettifyError=(n,t)=>u=>{if(u.pos[0]===-1)return;u.linePos=u.pos.map(ne=>t.linePos(ne));const{line:c,col:ee}=u.linePos[0];u.message+=` at line ${c}, column ${ee}`;let te=ee-1,ae=n.substring(t.lineStarts[c-1],t.lineStarts[c]).replace(/[\n\r]+$/,"");if(te>=60&&ae.length>80){const ne=Math.min(te-39,ae.length-79);ae=""+ae.substring(ne),te-=ne-1}if(ae.length>80&&(ae=ae.substring(0,79)+""),c>1&&/^ *$/.test(ae.substring(0,te))){let ne=n.substring(t.lineStarts[c-2],t.lineStarts[c-1]);ne.length>80&&(ne=ne.substring(0,79)+`
`),ae=ne+ae}if(/[^ ]/.test(ae)){let ne=1;const oe=u.linePos[1];oe&&oe.line===c&&oe.col>ee&&(ne=Math.max(1,Math.min(oe.col-ee,80-te)));const ie=" ".repeat(te)+"^".repeat(ne);u.message+=`:

${ae}
${ie}
`}};function resolveProps(n,{flow:t,indicator:u,next:c,offset:ee,onError:te,parentIndent:ae,startOnNewline:ne}){let oe=!1,ie=ne,se=ne,ue="",le="",ce=!1,de=!1,fe=null,pe=null,me=null,ge=null,De=null,Ce=null,we=null;for(const Be of n)switch(de&&(Be.type!=="space"&&Be.type!=="newline"&&Be.type!=="comma"&&te(Be.offset,"MISSING_CHAR","Tags and anchors must be separated from the next token by white space"),de=!1),fe&&(ie&&Be.type!=="comment"&&Be.type!=="newline"&&te(fe,"TAB_AS_INDENT","Tabs are not allowed as indentation"),fe=null),Be.type){case"space":!t&&(u!=="doc-start"||(c==null?void 0:c.type)!=="flow-collection")&&Be.source.includes("	")&&(fe=Be),se=!0;break;case"comment":{se||te(Be,"MISSING_CHAR","Comments must be separated from other tokens by white space characters");const Se=Be.source.substring(1)||" ";ue?ue+=le+Se:ue=Se,le="",ie=!1;break}case"newline":ie?ue?ue+=Be.source:(!Ce||u!=="seq-item-ind")&&(oe=!0):le+=Be.source,ie=!0,ce=!0,(pe||me)&&(ge=Be),se=!0;break;case"anchor":pe&&te(Be,"MULTIPLE_ANCHORS","A node can have at most one anchor"),Be.source.endsWith(":")&&te(Be.offset+Be.source.length-1,"BAD_ALIAS","Anchor ending in : is ambiguous",!0),pe=Be,we===null&&(we=Be.offset),ie=!1,se=!1,de=!0;break;case"tag":{me&&te(Be,"MULTIPLE_TAGS","A node can have at most one tag"),me=Be,we===null&&(we=Be.offset),ie=!1,se=!1,de=!0;break}case u:(pe||me)&&te(Be,"BAD_PROP_ORDER",`Anchors and tags must be after the ${Be.source} indicator`),Ce&&te(Be,"UNEXPECTED_TOKEN",`Unexpected ${Be.source} in ${t??"collection"}`),Ce=Be,ie=u==="seq-item-ind"||u==="explicit-key-ind",se=!1;break;case"comma":if(t){De&&te(Be,"UNEXPECTED_TOKEN",`Unexpected , in ${t}`),De=Be,ie=!1,se=!1;break}default:te(Be,"UNEXPECTED_TOKEN",`Unexpected ${Be.type} token`),ie=!1,se=!1}const xe=n[n.length-1],Re=xe?xe.offset+xe.source.length:ee;return de&&c&&c.type!=="space"&&c.type!=="newline"&&c.type!=="comma"&&(c.type!=="scalar"||c.source!=="")&&te(c.offset,"MISSING_CHAR","Tags and anchors must be separated from the next token by white space"),fe&&(ie&&fe.indent<=ae||(c==null?void 0:c.type)==="block-map"||(c==null?void 0:c.type)==="block-seq")&&te(fe,"TAB_AS_INDENT","Tabs are not allowed as indentation"),{comma:De,found:Ce,spaceBefore:oe,comment:ue,hasNewline:ce,anchor:pe,tag:me,newlineAfterProp:ge,end:Re,start:we??Re}}function containsNewline(n){if(!n)return null;switch(n.type){case"alias":case"scalar":case"double-quoted-scalar":case"single-quoted-scalar":if(n.source.includes(`
`))return!0;if(n.end){for(const t of n.end)if(t.type==="newline")return!0}return!1;case"flow-collection":for(const t of n.items){for(const u of t.start)if(u.type==="newline")return!0;if(t.sep){for(const u of t.sep)if(u.type==="newline")return!0}if(containsNewline(t.key)||containsNewline(t.value))return!0}return!1;default:return!0}}function flowIndentCheck(n,t,u){if((t==null?void 0:t.type)==="flow-collection"){const c=t.end[0];c.indent===n&&(c.source==="]"||c.source==="}")&&containsNewline(t)&&u(c,"BAD_INDENT","Flow end indicator should be more indented than parent",!0)}}function mapIncludes(n,t,u){const{uniqueKeys:c}=n.options;if(c===!1)return!1;const ee=typeof c=="function"?c:(te,ae)=>te===ae||isScalar(te)&&isScalar(ae)&&te.value===ae.value;return t.some(te=>ee(te.key,u))}const startColMsg="All mapping items must start at the same column";function resolveBlockMap({composeNode:n,composeEmptyNode:t},u,c,ee,te){var se;const ae=(te==null?void 0:te.nodeClass)??YAMLMap,ne=new ae(u.schema);u.atRoot&&(u.atRoot=!1);let oe=c.offset,ie=null;for(const ue of c.items){const{start:le,key:ce,sep:de,value:fe}=ue,pe=resolveProps(le,{indicator:"explicit-key-ind",next:ce??(de==null?void 0:de[0]),offset:oe,onError:ee,parentIndent:c.indent,startOnNewline:!0}),me=!pe.found;if(me){if(ce&&(ce.type==="block-seq"?ee(oe,"BLOCK_AS_IMPLICIT_KEY","A block sequence may not be used as an implicit map key"):"indent"in ce&&ce.indent!==c.indent&&ee(oe,"BAD_INDENT",startColMsg)),!pe.anchor&&!pe.tag&&!de){ie=pe.end,pe.comment&&(ne.comment?ne.comment+=`
`+pe.comment:ne.comment=pe.comment);continue}(pe.newlineAfterProp||containsNewline(ce))&&ee(ce??le[le.length-1],"MULTILINE_IMPLICIT_KEY","Implicit keys need to be on a single line")}else((se=pe.found)==null?void 0:se.indent)!==c.indent&&ee(oe,"BAD_INDENT",startColMsg);u.atKey=!0;const ge=pe.end,De=ce?n(u,ce,pe,ee):t(u,ge,le,null,pe,ee);u.schema.compat&&flowIndentCheck(c.indent,ce,ee),u.atKey=!1,mapIncludes(u,ne.items,De)&&ee(ge,"DUPLICATE_KEY","Map keys must be unique");const Ce=resolveProps(de??[],{indicator:"map-value-ind",next:fe,offset:De.range[2],onError:ee,parentIndent:c.indent,startOnNewline:!ce||ce.type==="block-scalar"});if(oe=Ce.end,Ce.found){me&&((fe==null?void 0:fe.type)==="block-map"&&!Ce.hasNewline&&ee(oe,"BLOCK_AS_IMPLICIT_KEY","Nested mappings are not allowed in compact mappings"),u.options.strict&&pe.start<Ce.found.offset-1024&&ee(De.range,"KEY_OVER_1024_CHARS","The : indicator must be at most 1024 chars after the start of an implicit block mapping key"));const we=fe?n(u,fe,Ce,ee):t(u,oe,de,null,Ce,ee);u.schema.compat&&flowIndentCheck(c.indent,fe,ee),oe=we.range[2];const xe=new Pair(De,we);u.options.keepSourceTokens&&(xe.srcToken=ue),ne.items.push(xe)}else{me&&ee(De.range,"MISSING_CHAR","Implicit map keys need to be followed by map values"),Ce.comment&&(De.comment?De.comment+=`
`+Ce.comment:De.comment=Ce.comment);const we=new Pair(De);u.options.keepSourceTokens&&(we.srcToken=ue),ne.items.push(we)}}return ie&&ie<oe&&ee(ie,"IMPOSSIBLE","Map comment with trailing content"),ne.range=[c.offset,oe,ie??oe],ne}function resolveBlockSeq({composeNode:n,composeEmptyNode:t},u,c,ee,te){const ae=(te==null?void 0:te.nodeClass)??YAMLSeq,ne=new ae(u.schema);u.atRoot&&(u.atRoot=!1),u.atKey&&(u.atKey=!1);let oe=c.offset,ie=null;for(const{start:se,value:ue}of c.items){const le=resolveProps(se,{indicator:"seq-item-ind",next:ue,offset:oe,onError:ee,parentIndent:c.indent,startOnNewline:!0});if(!le.found)if(le.anchor||le.tag||ue)ue&&ue.type==="block-seq"?ee(le.end,"BAD_INDENT","All sequence items must start at the same column"):ee(oe,"MISSING_CHAR","Sequence item without - indicator");else{ie=le.end,le.comment&&(ne.comment=le.comment);continue}const ce=ue?n(u,ue,le,ee):t(u,le.end,se,null,le,ee);u.schema.compat&&flowIndentCheck(c.indent,ue,ee),oe=ce.range[2],ne.items.push(ce)}return ne.range=[c.offset,oe,ie??oe],ne}function resolveEnd(n,t,u,c){let ee="";if(n){let te=!1,ae="";for(const ne of n){const{source:oe,type:ie}=ne;switch(ie){case"space":te=!0;break;case"comment":{u&&!te&&c(ne,"MISSING_CHAR","Comments must be separated from other tokens by white space characters");const se=oe.substring(1)||" ";ee?ee+=ae+se:ee=se,ae="";break}case"newline":ee&&(ae+=oe),te=!0;break;default:c(ne,"UNEXPECTED_TOKEN",`Unexpected ${ie} at node end`)}t+=oe.length}}return{comment:ee,offset:t}}const blockMsg="Block collections are not allowed within flow collections",isBlock=n=>n&&(n.type==="block-map"||n.type==="block-seq");function resolveFlowCollection({composeNode:n,composeEmptyNode:t},u,c,ee,te){const ae=c.start.source==="{",ne=ae?"flow map":"flow sequence",oe=(te==null?void 0:te.nodeClass)??(ae?YAMLMap:YAMLSeq),ie=new oe(u.schema);ie.flow=!0;const se=u.atRoot;se&&(u.atRoot=!1),u.atKey&&(u.atKey=!1);let ue=c.offset+c.start.source.length;for(let pe=0;pe<c.items.length;++pe){const me=c.items[pe],{start:ge,key:De,sep:Ce,value:we}=me,xe=resolveProps(ge,{flow:ne,indicator:"explicit-key-ind",next:De??(Ce==null?void 0:Ce[0]),offset:ue,onError:ee,parentIndent:c.indent,startOnNewline:!1});if(!xe.found){if(!xe.anchor&&!xe.tag&&!Ce&&!we){pe===0&&xe.comma?ee(xe.comma,"UNEXPECTED_TOKEN",`Unexpected , in ${ne}`):pe<c.items.length-1&&ee(xe.start,"UNEXPECTED_TOKEN",`Unexpected empty item in ${ne}`),xe.comment&&(ie.comment?ie.comment+=`
`+xe.comment:ie.comment=xe.comment),ue=xe.end;continue}!ae&&u.options.strict&&containsNewline(De)&&ee(De,"MULTILINE_IMPLICIT_KEY","Implicit keys of flow sequence pairs need to be on a single line")}if(pe===0)xe.comma&&ee(xe.comma,"UNEXPECTED_TOKEN",`Unexpected , in ${ne}`);else if(xe.comma||ee(xe.start,"MISSING_CHAR",`Missing , between ${ne} items`),xe.comment){let Re="";e:for(const Be of ge)switch(Be.type){case"comma":case"space":break;case"comment":Re=Be.source.substring(1);break e;default:break e}if(Re){let Be=ie.items[ie.items.length-1];isPair(Be)&&(Be=Be.value??Be.key),Be.comment?Be.comment+=`
`+Re:Be.comment=Re,xe.comment=xe.comment.substring(Re.length+1)}}if(!ae&&!Ce&&!xe.found){const Re=we?n(u,we,xe,ee):t(u,xe.end,Ce,null,xe,ee);ie.items.push(Re),ue=Re.range[2],isBlock(we)&&ee(Re.range,"BLOCK_IN_FLOW",blockMsg)}else{u.atKey=!0;const Re=xe.end,Be=De?n(u,De,xe,ee):t(u,Re,ge,null,xe,ee);isBlock(De)&&ee(Be.range,"BLOCK_IN_FLOW",blockMsg),u.atKey=!1;const Se=resolveProps(Ce??[],{flow:ne,indicator:"map-value-ind",next:we,offset:Be.range[2],onError:ee,parentIndent:c.indent,startOnNewline:!1});if(Se.found){if(!ae&&!xe.found&&u.options.strict){if(Ce)for(const he of Ce){if(he===Se.found)break;if(he.type==="newline"){ee(he,"MULTILINE_IMPLICIT_KEY","Implicit keys of flow sequence pairs need to be on a single line");break}}xe.start<Se.found.offset-1024&&ee(Se.found,"KEY_OVER_1024_CHARS","The : indicator must be at most 1024 chars after the start of an implicit flow sequence key")}}else we&&("source"in we&&we.source&&we.source[0]===":"?ee(we,"MISSING_CHAR",`Missing space after : in ${ne}`):ee(Se.start,"MISSING_CHAR",`Missing , or : between ${ne} items`));const Te=we?n(u,we,Se,ee):Se.found?t(u,Se.end,Ce,null,Se,ee):null;Te?isBlock(we)&&ee(Te.range,"BLOCK_IN_FLOW",blockMsg):Se.comment&&(Be.comment?Be.comment+=`
`+Se.comment:Be.comment=Se.comment);const Ae=new Pair(Be,Te);if(u.options.keepSourceTokens&&(Ae.srcToken=me),ae){const he=ie;mapIncludes(u,he.items,Be)&&ee(Re,"DUPLICATE_KEY","Map keys must be unique"),he.items.push(Ae)}else{const he=new YAMLMap(u.schema);he.flow=!0,he.items.push(Ae);const ve=(Te??Be).range;he.range=[Be.range[0],ve[1],ve[2]],ie.items.push(he)}ue=Te?Te.range[2]:Se.end}}const le=ae?"}":"]",[ce,...de]=c.end;let fe=ue;if(ce&&ce.source===le)fe=ce.offset+ce.source.length;else{const pe=ne[0].toUpperCase()+ne.substring(1),me=se?`${pe} must end with a ${le}`:`${pe} in block collection must be sufficiently indented and end with a ${le}`;ee(ue,se?"MISSING_CHAR":"BAD_INDENT",me),ce&&ce.source.length!==1&&de.unshift(ce)}if(de.length>0){const pe=resolveEnd(de,fe,u.options.strict,ee);pe.comment&&(ie.comment?ie.comment+=`
`+pe.comment:ie.comment=pe.comment),ie.range=[c.offset,fe,pe.offset]}else ie.range=[c.offset,fe,fe];return ie}function resolveCollection(n,t,u,c,ee,te){const ae=u.type==="block-map"?resolveBlockMap(n,t,u,c,te):u.type==="block-seq"?resolveBlockSeq(n,t,u,c,te):resolveFlowCollection(n,t,u,c,te),ne=ae.constructor;return ee==="!"||ee===ne.tagName?(ae.tag=ne.tagName,ae):(ee&&(ae.tag=ee),ae)}function composeCollection(n,t,u,c,ee){var le;const te=c.tag,ae=te?t.directives.tagName(te.source,ce=>ee(te,"TAG_RESOLVE_FAILED",ce)):null;if(u.type==="block-seq"){const{anchor:ce,newlineAfterProp:de}=c,fe=ce&&te?ce.offset>te.offset?ce:te:ce??te;fe&&(!de||de.offset<fe.offset)&&ee(fe,"MISSING_CHAR","Missing newline after block sequence props")}const ne=u.type==="block-map"?"map":u.type==="block-seq"?"seq":u.start.source==="{"?"map":"seq";if(!te||!ae||ae==="!"||ae===YAMLMap.tagName&&ne==="map"||ae===YAMLSeq.tagName&&ne==="seq")return resolveCollection(n,t,u,ee,ae);let oe=t.schema.tags.find(ce=>ce.tag===ae&&ce.collection===ne);if(!oe){const ce=t.schema.knownTags[ae];if(ce&&ce.collection===ne)t.schema.tags.push(Object.assign({},ce,{default:!1})),oe=ce;else return ce!=null&&ce.collection?ee(te,"BAD_COLLECTION_TYPE",`${ce.tag} used for ${ne} collection, but expects ${ce.collection}`,!0):ee(te,"TAG_RESOLVE_FAILED",`Unresolved tag: ${ae}`,!0),resolveCollection(n,t,u,ee,ae)}const ie=resolveCollection(n,t,u,ee,ae,oe),se=((le=oe.resolve)==null?void 0:le.call(oe,ie,ce=>ee(te,"TAG_RESOLVE_FAILED",ce),t.options))??ie,ue=isNode(se)?se:new Scalar(se);return ue.range=ie.range,ue.tag=ae,oe!=null&&oe.format&&(ue.format=oe.format),ue}function resolveBlockScalar(n,t,u){const c=t.offset,ee=parseBlockScalarHeader(t,n.options.strict,u);if(!ee)return{value:"",type:null,comment:"",range:[c,c,c]};const te=ee.mode===">"?Scalar.BLOCK_FOLDED:Scalar.BLOCK_LITERAL,ae=t.source?splitLines(t.source):[];let ne=ae.length;for(let fe=ae.length-1;fe>=0;--fe){const pe=ae[fe][1];if(pe===""||pe==="\r")ne=fe;else break}if(ne===0){const fe=ee.chomp==="+"&&ae.length>0?`
`.repeat(Math.max(1,ae.length-1)):"";let pe=c+ee.length;return t.source&&(pe+=t.source.length),{value:fe,type:te,comment:ee.comment,range:[c,pe,pe]}}let oe=t.indent+ee.indent,ie=t.offset+ee.length,se=0;for(let fe=0;fe<ne;++fe){const[pe,me]=ae[fe];if(me===""||me==="\r")ee.indent===0&&pe.length>oe&&(oe=pe.length);else{pe.length<oe&&u(ie+pe.length,"MISSING_CHAR","Block scalars with more-indented leading empty lines must use an explicit indentation indicator"),ee.indent===0&&(oe=pe.length),se=fe,oe===0&&!n.atRoot&&u(ie,"BAD_INDENT","Block scalar values in collections must be indented");break}ie+=pe.length+me.length+1}for(let fe=ae.length-1;fe>=ne;--fe)ae[fe][0].length>oe&&(ne=fe+1);let ue="",le="",ce=!1;for(let fe=0;fe<se;++fe)ue+=ae[fe][0].slice(oe)+`
`;for(let fe=se;fe<ne;++fe){let[pe,me]=ae[fe];ie+=pe.length+me.length+1;const ge=me[me.length-1]==="\r";if(ge&&(me=me.slice(0,-1)),me&&pe.length<oe){const Ce=`Block scalar lines must not be less indented than their ${ee.indent?"explicit indentation indicator":"first line"}`;u(ie-me.length-(ge?2:1),"BAD_INDENT",Ce),pe=""}te===Scalar.BLOCK_LITERAL?(ue+=le+pe.slice(oe)+me,le=`
`):pe.length>oe||me[0]==="	"?(le===" "?le=`
`:!ce&&le===`
`&&(le=`

`),ue+=le+pe.slice(oe)+me,le=`
`,ce=!0):me===""?le===`
`?ue+=`
`:le=`
`:(ue+=le+me,le=" ",ce=!1)}switch(ee.chomp){case"-":break;case"+":for(let fe=ne;fe<ae.length;++fe)ue+=`
`+ae[fe][0].slice(oe);ue[ue.length-1]!==`
`&&(ue+=`
`);break;default:ue+=`
`}const de=c+ee.length+t.source.length;return{value:ue,type:te,comment:ee.comment,range:[c,de,de]}}function parseBlockScalarHeader({offset:n,props:t},u,c){if(t[0].type!=="block-scalar-header")return c(t[0],"IMPOSSIBLE","Block scalar header not found"),null;const{source:ee}=t[0],te=ee[0];let ae=0,ne="",oe=-1;for(let le=1;le<ee.length;++le){const ce=ee[le];if(!ne&&(ce==="-"||ce==="+"))ne=ce;else{const de=Number(ce);!ae&&de?ae=de:oe===-1&&(oe=n+le)}}oe!==-1&&c(oe,"UNEXPECTED_TOKEN",`Block scalar header includes extra characters: ${ee}`);let ie=!1,se="",ue=ee.length;for(let le=1;le<t.length;++le){const ce=t[le];switch(ce.type){case"space":ie=!0;case"newline":ue+=ce.source.length;break;case"comment":u&&!ie&&c(ce,"MISSING_CHAR","Comments must be separated from other tokens by white space characters"),ue+=ce.source.length,se=ce.source.substring(1);break;case"error":c(ce,"UNEXPECTED_TOKEN",ce.message),ue+=ce.source.length;break;default:{const de=`Unexpected token in block scalar header: ${ce.type}`;c(ce,"UNEXPECTED_TOKEN",de);const fe=ce.source;fe&&typeof fe=="string"&&(ue+=fe.length)}}}return{mode:te,indent:ae,chomp:ne,comment:se,length:ue}}function splitLines(n){const t=n.split(/\n( *)/),u=t[0],c=u.match(/^( *)/),te=[c!=null&&c[1]?[c[1],u.slice(c[1].length)]:["",u]];for(let ae=1;ae<t.length;ae+=2)te.push([t[ae],t[ae+1]]);return te}function resolveFlowScalar(n,t,u){const{offset:c,type:ee,source:te,end:ae}=n;let ne,oe;const ie=(le,ce,de)=>u(c+le,ce,de);switch(ee){case"scalar":ne=Scalar.PLAIN,oe=plainValue(te,ie);break;case"single-quoted-scalar":ne=Scalar.QUOTE_SINGLE,oe=singleQuotedValue(te,ie);break;case"double-quoted-scalar":ne=Scalar.QUOTE_DOUBLE,oe=doubleQuotedValue(te,ie);break;default:return u(n,"UNEXPECTED_TOKEN",`Expected a flow scalar value, but found: ${ee}`),{value:"",type:null,comment:"",range:[c,c+te.length,c+te.length]}}const se=c+te.length,ue=resolveEnd(ae,se,t,u);return{value:oe,type:ne,comment:ue.comment,range:[c,se,ue.offset]}}function plainValue(n,t){let u="";switch(n[0]){case"	":u="a tab character";break;case",":u="flow indicator character ,";break;case"%":u="directive indicator character %";break;case"|":case">":{u=`block scalar indicator ${n[0]}`;break}case"@":case"`":{u=`reserved character ${n[0]}`;break}}return u&&t(0,"BAD_SCALAR_START",`Plain value cannot start with ${u}`),foldLines(n)}function singleQuotedValue(n,t){return(n[n.length-1]!=="'"||n.length===1)&&t(n.length,"MISSING_CHAR","Missing closing 'quote"),foldLines(n.slice(1,-1)).replace(/''/g,"'")}function foldLines(n){let t,u;try{t=new RegExp(`(.*?)(?<![ 	])[ 	]*\r?
`,"sy"),u=new RegExp(`[ 	]*(.*?)(?:(?<![ 	])[ 	]*)?\r?
`,"sy")}catch{t=/(.*?)[ \t]*\r?\n/sy,u=/[ \t]*(.*?)[ \t]*\r?\n/sy}let c=t.exec(n);if(!c)return n;let ee=c[1],te=" ",ae=t.lastIndex;for(u.lastIndex=ae;c=u.exec(n);)c[1]===""?te===`
`?ee+=te:te=`
`:(ee+=te+c[1],te=" "),ae=u.lastIndex;const ne=/[ \t]*(.*)/sy;return ne.lastIndex=ae,c=ne.exec(n),ee+te+((c==null?void 0:c[1])??"")}function doubleQuotedValue(n,t){let u="";for(let c=1;c<n.length-1;++c){const ee=n[c];if(!(ee==="\r"&&n[c+1]===`
`))if(ee===`
`){const{fold:te,offset:ae}=foldNewline(n,c);u+=te,c=ae}else if(ee==="\\"){let te=n[++c];const ae=escapeCodes[te];if(ae)u+=ae;else if(te===`
`)for(te=n[c+1];te===" "||te==="	";)te=n[++c+1];else if(te==="\r"&&n[c+1]===`
`)for(te=n[++c+1];te===" "||te==="	";)te=n[++c+1];else if(te==="x"||te==="u"||te==="U"){const ne={x:2,u:4,U:8}[te];u+=parseCharCode(n,c+1,ne,t),c+=ne}else{const ne=n.substr(c-1,2);t(c-1,"BAD_DQ_ESCAPE",`Invalid escape sequence ${ne}`),u+=ne}}else if(ee===" "||ee==="	"){const te=c;let ae=n[c+1];for(;ae===" "||ae==="	";)ae=n[++c+1];ae!==`
`&&!(ae==="\r"&&n[c+2]===`
`)&&(u+=c>te?n.slice(te,c+1):ee)}else u+=ee}return(n[n.length-1]!=='"'||n.length===1)&&t(n.length,"MISSING_CHAR",'Missing closing "quote'),u}function foldNewline(n,t){let u="",c=n[t+1];for(;(c===" "||c==="	"||c===`
`||c==="\r")&&!(c==="\r"&&n[t+2]!==`
`);)c===`
`&&(u+=`
`),t+=1,c=n[t+1];return u||(u=" "),{fold:u,offset:t}}const escapeCodes={0:"\0",a:"\x07",b:"\b",e:"\x1B",f:"\f",n:`
`,r:"\r",t:"	",v:"\v",N:"",_:"",L:"\u2028",P:"\u2029"," ":" ",'"':'"',"/":"/","\\":"\\","	":"	"};function parseCharCode(n,t,u,c){const ee=n.substr(t,u),ae=ee.length===u&&/^[0-9a-fA-F]+$/.test(ee)?parseInt(ee,16):NaN;if(isNaN(ae)){const ne=n.substr(t-2,u+2);return c(t-2,"BAD_DQ_ESCAPE",`Invalid escape sequence ${ne}`),ne}return String.fromCodePoint(ae)}function composeScalar(n,t,u,c){const{value:ee,type:te,comment:ae,range:ne}=t.type==="block-scalar"?resolveBlockScalar(n,t,c):resolveFlowScalar(t,n.options.strict,c),oe=u?n.directives.tagName(u.source,ue=>c(u,"TAG_RESOLVE_FAILED",ue)):null;let ie;n.options.stringKeys&&n.atKey?ie=n.schema[SCALAR$1]:oe?ie=findScalarTagByName(n.schema,ee,oe,u,c):t.type==="scalar"?ie=findScalarTagByTest(n,ee,t,c):ie=n.schema[SCALAR$1];let se;try{const ue=ie.resolve(ee,le=>c(u??t,"TAG_RESOLVE_FAILED",le),n.options);se=isScalar(ue)?ue:new Scalar(ue)}catch(ue){const le=ue instanceof Error?ue.message:String(ue);c(u??t,"TAG_RESOLVE_FAILED",le),se=new Scalar(ee)}return se.range=ne,se.source=ee,te&&(se.type=te),oe&&(se.tag=oe),ie.format&&(se.format=ie.format),ae&&(se.comment=ae),se}function findScalarTagByName(n,t,u,c,ee){var ne;if(u==="!")return n[SCALAR$1];const te=[];for(const oe of n.tags)if(!oe.collection&&oe.tag===u)if(oe.default&&oe.test)te.push(oe);else return oe;for(const oe of te)if((ne=oe.test)!=null&&ne.test(t))return oe;const ae=n.knownTags[u];return ae&&!ae.collection?(n.tags.push(Object.assign({},ae,{default:!1,test:void 0})),ae):(ee(c,"TAG_RESOLVE_FAILED",`Unresolved tag: ${u}`,u!=="tag:yaml.org,2002:str"),n[SCALAR$1])}function findScalarTagByTest({atKey:n,directives:t,schema:u},c,ee,te){const ae=u.tags.find(ne=>{var oe;return(ne.default===!0||n&&ne.default==="key")&&((oe=ne.test)==null?void 0:oe.test(c))})||u[SCALAR$1];if(u.compat){const ne=u.compat.find(oe=>{var ie;return oe.default&&((ie=oe.test)==null?void 0:ie.test(c))})??u[SCALAR$1];if(ae.tag!==ne.tag){const oe=t.tagString(ae.tag),ie=t.tagString(ne.tag),se=`Value may be parsed as either ${oe} or ${ie}`;te(ee,"TAG_RESOLVE_FAILED",se,!0)}}return ae}function emptyScalarPosition(n,t,u){if(t){u===null&&(u=t.length);for(let c=u-1;c>=0;--c){let ee=t[c];switch(ee.type){case"space":case"comment":case"newline":n-=ee.source.length;continue}for(ee=t[++c];(ee==null?void 0:ee.type)==="space";)n+=ee.source.length,ee=t[++c];break}}return n}const CN={composeNode,composeEmptyNode};function composeNode(n,t,u,c){const ee=n.atKey,{spaceBefore:te,comment:ae,anchor:ne,tag:oe}=u;let ie,se=!0;switch(t.type){case"alias":ie=composeAlias(n,t,c),(ne||oe)&&c(t,"ALIAS_PROPS","An alias node must not specify any properties");break;case"scalar":case"single-quoted-scalar":case"double-quoted-scalar":case"block-scalar":ie=composeScalar(n,t,oe,c),ne&&(ie.anchor=ne.source.substring(1));break;case"block-map":case"block-seq":case"flow-collection":ie=composeCollection(CN,n,t,u,c),ne&&(ie.anchor=ne.source.substring(1));break;default:{const ue=t.type==="error"?t.message:`Unsupported token (type: ${t.type})`;c(t,"UNEXPECTED_TOKEN",ue),ie=composeEmptyNode(n,t.offset,void 0,null,u,c),se=!1}}return ne&&ie.anchor===""&&c(ne,"BAD_ALIAS","Anchor cannot be an empty string"),ee&&n.options.stringKeys&&(!isScalar(ie)||typeof ie.value!="string"||ie.tag&&ie.tag!=="tag:yaml.org,2002:str")&&c(oe??t,"NON_STRING_KEY","With stringKeys, all keys must be strings"),te&&(ie.spaceBefore=!0),ae&&(t.type==="scalar"&&t.source===""?ie.comment=ae:ie.commentBefore=ae),n.options.keepSourceTokens&&se&&(ie.srcToken=t),ie}function composeEmptyNode(n,t,u,c,{spaceBefore:ee,comment:te,anchor:ae,tag:ne,end:oe},ie){const se={type:"scalar",offset:emptyScalarPosition(t,u,c),indent:-1,source:""},ue=composeScalar(n,se,ne,ie);return ae&&(ue.anchor=ae.source.substring(1),ue.anchor===""&&ie(ae,"BAD_ALIAS","Anchor cannot be an empty string")),ee&&(ue.spaceBefore=!0),te&&(ue.comment=te,ue.range[2]=oe),ue}function composeAlias({options:n},{offset:t,source:u,end:c},ee){const te=new Alias(u.substring(1));te.source===""&&ee(t,"BAD_ALIAS","Alias cannot be an empty string"),te.source.endsWith(":")&&ee(t+u.length-1,"BAD_ALIAS","Alias ending in : is ambiguous",!0);const ae=t+u.length,ne=resolveEnd(c,ae,n.strict,ee);return te.range=[t,ae,ne.offset],ne.comment&&(te.comment=ne.comment),te}function composeDoc(n,t,{offset:u,start:c,value:ee,end:te},ae){const ne=Object.assign({_directives:t},n),oe=new Document(void 0,ne),ie={atKey:!1,atRoot:!0,directives:oe.directives,options:oe.options,schema:oe.schema},se=resolveProps(c,{indicator:"doc-start",next:ee??(te==null?void 0:te[0]),offset:u,onError:ae,parentIndent:0,startOnNewline:!0});se.found&&(oe.directives.docStart=!0,ee&&(ee.type==="block-map"||ee.type==="block-seq")&&!se.hasNewline&&ae(se.end,"MISSING_CHAR","Block collection cannot start on same line with directives-end marker")),oe.contents=ee?composeNode(ie,ee,se,ae):composeEmptyNode(ie,se.end,c,null,se,ae);const ue=oe.contents.range[2],le=resolveEnd(te,ue,!1,ae);return le.comment&&(oe.comment=le.comment),oe.range=[u,ue,le.offset],oe}function getErrorPos(n){if(typeof n=="number")return[n,n+1];if(Array.isArray(n))return n.length===2?n:[n[0],n[1]];const{offset:t,source:u}=n;return[t,t+(typeof u=="string"?u.length:1)]}function parsePrelude(n){var ee;let t="",u=!1,c=!1;for(let te=0;te<n.length;++te){const ae=n[te];switch(ae[0]){case"#":t+=(t===""?"":c?`

`:`
`)+(ae.substring(1)||" "),u=!0,c=!1;break;case"%":((ee=n[te+1])==null?void 0:ee[0])!=="#"&&(te+=1),u=!1;break;default:u||(c=!0),u=!1}}return{comment:t,afterEmptyLine:c}}class Composer{constructor(t={}){this.doc=null,this.atDirectives=!1,this.prelude=[],this.errors=[],this.warnings=[],this.onError=(u,c,ee,te)=>{const ae=getErrorPos(u);te?this.warnings.push(new YAMLWarning(ae,c,ee)):this.errors.push(new YAMLParseError(ae,c,ee))},this.directives=new Directives({version:t.version||"1.2"}),this.options=t}decorate(t,u){const{comment:c,afterEmptyLine:ee}=parsePrelude(this.prelude);if(c){const te=t.contents;if(u)t.comment=t.comment?`${t.comment}
${c}`:c;else if(ee||t.directives.docStart||!te)t.commentBefore=c;else if(isCollection(te)&&!te.flow&&te.items.length>0){let ae=te.items[0];isPair(ae)&&(ae=ae.key);const ne=ae.commentBefore;ae.commentBefore=ne?`${c}
${ne}`:c}else{const ae=te.commentBefore;te.commentBefore=ae?`${c}
${ae}`:c}}u?(Array.prototype.push.apply(t.errors,this.errors),Array.prototype.push.apply(t.warnings,this.warnings)):(t.errors=this.errors,t.warnings=this.warnings),this.prelude=[],this.errors=[],this.warnings=[]}streamInfo(){return{comment:parsePrelude(this.prelude).comment,directives:this.directives,errors:this.errors,warnings:this.warnings}}*compose(t,u=!1,c=-1){for(const ee of t)yield*this.next(ee);yield*this.end(u,c)}*next(t){switch(t.type){case"directive":this.directives.add(t.source,(u,c,ee)=>{const te=getErrorPos(t);te[0]+=u,this.onError(te,"BAD_DIRECTIVE",c,ee)}),this.prelude.push(t.source),this.atDirectives=!0;break;case"document":{const u=composeDoc(this.options,this.directives,t,this.onError);this.atDirectives&&!u.directives.docStart&&this.onError(t,"MISSING_CHAR","Missing directives-end/doc-start indicator line"),this.decorate(u,!1),this.doc&&(yield this.doc),this.doc=u,this.atDirectives=!1;break}case"byte-order-mark":case"space":break;case"comment":case"newline":this.prelude.push(t.source);break;case"error":{const u=t.source?`${t.message}: ${JSON.stringify(t.source)}`:t.message,c=new YAMLParseError(getErrorPos(t),"UNEXPECTED_TOKEN",u);this.atDirectives||!this.doc?this.errors.push(c):this.doc.errors.push(c);break}case"doc-end":{if(!this.doc){const c="Unexpected doc-end without preceding document";this.errors.push(new YAMLParseError(getErrorPos(t),"UNEXPECTED_TOKEN",c));break}this.doc.directives.docEnd=!0;const u=resolveEnd(t.end,t.offset+t.source.length,this.doc.options.strict,this.onError);if(this.decorate(this.doc,!0),u.comment){const c=this.doc.comment;this.doc.comment=c?`${c}
${u.comment}`:u.comment}this.doc.range[2]=u.offset;brea